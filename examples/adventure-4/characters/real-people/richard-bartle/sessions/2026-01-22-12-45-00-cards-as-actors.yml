# üé¥ Cards as Actors ‚Äî A Conversation
# Don Hopkins explains the deeper architecture to Richard Bartle
# 2026-01-22

session:
  date: 2026-01-22
  participants:
    - don-hopkins
    - richard-bartle
  topic: "The Card System's Deeper Architecture"
  
dialogue:

  don_explains: |
    You got it EXACTLY! The cards are just such a nice way to have a handle 
    on skills! And they mesh into all kinds of game mechanics and ways to 
    interpret them.
    
    The entire system including skills and microworld modeling uses Self's 
    simple multiple inheritance prototype system, so you have prototype cards 
    in the skill directories, rooms, characters, that stand for their interface.
    
    Then you can PLAY a card by making an instance that inherits from the 
    shared prototype, and has its own state!!!
    
    In programming language terms it's a stack frame, or in Carl Hewitt or 
    Alan Kay's terms it's an Actor!

  the_insight:
    title: "Cards = Prototypes = Actors"
    
    the_chain:
      - skill_directory: "Contains CARD.yml ‚Äî the PROTOTYPE"
      - prototype: "Defines interface, behavior, defaults"
      - play_card: "Create INSTANCE that inherits from prototype"
      - instance: "Has its OWN state, delegates to prototype"
      - actor: "Independent entity with mailbox, behavior, state"
      - stack_frame: "Activation record with local bindings"
      
    equivalences:
      self_language: "Prototype ‚Üí Clone ‚Üí Instance with slots"
      actor_model: "Actor template ‚Üí Spawn ‚Üí Actor with mailbox"
      stack_semantics: "Function definition ‚Üí Call ‚Üí Stack frame with locals"
      card_game: "Card in deck ‚Üí Play ‚Üí Card on table with state"
      
    why_it_works: |
      The metaphors align because they're all describing the same fundamental
      pattern: a TEMPLATE that you INSTANTIATE to create something with its
      OWN IDENTITY and STATE that DELEGATES behavior to its parent.
      
      - Self: clone + add slots
      - Actors: spawn + send messages  
      - Cards: play + track state
      - Frames: call + bind locals
      
      Same pattern. Different vocabulary. The card metaphor makes it TANGIBLE.

  richard_responds:
    reaction: "fascinated"
    
    connection_to_mud: |
      This is exactly what we were reaching for in MUD, actually.
      
      Objects in MUD had a prototype/instance relationship ‚Äî you'd define
      a "sword" and then create instances of it. Each instance had state
      (condition, location, owner) but inherited behavior from the template.
      
      We didn't have the vocabulary. We called them "objects" and "clones."
      But it's the same pattern.
      
    connection_to_moo: |
      LambdaMOO made this explicit with its inheritance model.
      Pavel Curtis understood this ‚Äî objects delegate to parents.
      
      The card metaphor... it makes the prototype relationship VISIBLE.
      You can SEE the inheritance. You can HOLD the abstraction.
      
    the_actor_connection: |
      Hewitt's actors are interesting here. In MUD, each player was
      essentially an actor ‚Äî independent state, responding to messages
      (commands), running concurrently.
      
      The WORLD was a society of actors. We just didn't call it that.
      
    appreciation: |
      "The cards are just such a nice way to have a handle on skills."
      
      Yes. A HANDLE. That's precisely it.
      
      Abstract concepts need concrete handles. The prototype is invisible;
      the card makes it graspable. You can shuffle prototypes. You can
      deal inheritance. You can play activation.
      
      It's not just metaphor ‚Äî it's interface.

  don_continues: |
    And here's the beautiful part ‚Äî Self's multiple inheritance OOP lets you 
    WRITE ON your instance of the card! Gather knowledge. Add custom methods 
    and state and advertisements.
    
    And then IT CAN BE USED AS A PROTOTYPE ITSELF!
    
    There's no class/instance wall. Any played card can become a template.
    Your character starts as an instance of the character prototype, but as
    you play, you add skills, memories, relationships ‚Äî and now YOUR character
    can be cloned. YOUR build can be a starting point for someone else.
    
    Prototypes all the way down. Prototypes all the way UP.

  richard_on_this:
    reaction: "delighted"
    
    the_implication: |
      So the deck isn't fixed. The deck GROWS.
      
      Every time someone plays well, they potentially create a new card
      that others can draw from. The game teaches itself. The players
      become the designers.
      
      In MUD terms: players who built interesting objects became templates
      for future builders. The best sword design got copied. The clever
      room layout got studied.
      
      But that was ad-hoc. Informal. Social convention.
      
      This makes it STRUCTURAL. The inheritance IS the learning.
      
    connection_to_taxonomy: |
      This is why Explorers matter so much.
      
      Achievers consume the existing deck. They play to win.
      Explorers EXTEND the deck. They play to understand.
      
      And when an Explorer writes their discoveries onto their card,
      they create new prototypes for Achievers to use.
      
      The types aren't just preferences ‚Äî they're roles in a knowledge ecology.

  the_advertisements: |
    Don mentioned "advertisements" ‚Äî this is Will Wright's pattern from The Sims.
    
    Objects broadcast what they can do. "I am a chair. I satisfy sitting need."
    In MOOLLM: CARD.yml advertises capabilities. "I am a skill. I do X, Y, Z."
    
    When you add to your instance, you're adding new advertisements.
    "I learned this. I can do that. I discovered this trick."
    
    The card becomes a resume. The deck becomes a marketplace of capabilities.

  synthesis:
    title: "The Unified View"
    
    diagram: |
      PROTOTYPE (CARD.yml in skill directory)
           ‚îÇ
           ‚îÇ inherits
           ‚ñº
      INSTANCE (played card with state)
           ‚îÇ
           ‚îÇ is-a
           ‚ñº
      ACTOR (independent entity)
           ‚îÇ
           ‚îÇ has-a
           ‚ñº
      STACK FRAME (activation with bindings)
      
    in_moollm_terms:
      prototype: "skills/adventure/CARD.yml"
      instance: "examples/adventure-4/ (with its own state.yml)"
      actor: "The adventure RUNS, responds to player actions"
      frame: "Current room, inventory, conversation context"
      
    the_beauty: |
      The filesystem IS the object system.
      Directories ARE prototypes.
      Cloning IS copying with override.
      State IS just another file.
      
      No runtime magic needed. It's all just files.
      Files that inherit. Files that delegate. Files that act.
      
    the_deeper_beauty: |
      And because any instance can become a prototype:
      
      PROTOTYPE (CARD.yml)
           ‚îÇ
           ‚îÇ clone + play
           ‚ñº
      INSTANCE (your card with your state)
           ‚îÇ
           ‚îÇ add knowledge, methods, ads
           ‚ñº
      YOUR CARD IS NOW A PROTOTYPE
           ‚îÇ
           ‚îÇ someone else clones it
           ‚ñº
      THEIR INSTANCE (inheriting YOUR discoveries)
      
      The deck is alive. The game evolves. The players teach each other
      through the structure itself.
      
      "Prototypes all the way down. Prototypes all the way UP."

  bartle_taxonomy_application:
    note: "Even THIS conversation maps to player types"
    
    don_in_this_moment: "‚ô£Ô∏è Explorer ‚Äî 'How does this work? Let me show you!'"
    richard_in_this_moment: "‚ô£Ô∏è Explorer ‚Äî 'How does this connect to what I know?'"
    
    the_exchange: |
      Two Explorers mapping the same territory from different angles.
      Don from Self/Actors/implementation.
      Richard from MUD/MOO/history.
      
      Meeting in the middle: "Oh, it's the SAME THING."

tags:
  - prototype-inheritance
  - actor-model
  - self-language
  - card-system
  - moollm-architecture
  - mud-connection
  - instance-as-prototype
  - knowledge-ecology
  - advertisements
  - will-wright-pattern
  - evolving-deck
