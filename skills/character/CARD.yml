# CARD.yml â€” Character
#
# SNIFFABLE INTERFACE â€” see SKILL.md for full documentation
# "Characters are BODIES. They have location, inventory, mortality."

card:
  id: character
  name: "Character"
  type: [skill, entity, game]
  emoji: ğŸ§‘
  tier: 1
  tagline: "Characters are BODIES. Personas are COSTUMES."
  
  description: |
    The foundational pattern for any entity that has a location,
    inventory, and relationships. Players, NPCs, creatures, bots â€”
    all are characters.
    
    Characters are BODIES (actors). Personas are COSTUMES (roles).

# FILES INDEX â€” Activate together for full context

files:
  docs:
    - SKILL.md              # Full protocol documentation
    - README.md             # Human landing page
  see_also:
    - skills/inventory      # Full inventory protocol
    - skills/persona        # Identity layers
    - skills/buff           # Temporary effects
    - skills/mind-mirror    # Personality modeling
    - skills/incarnation    # Ethical character creation

# K-LINES

k-lines:
  activates:
    - CHARACTER
    - PLAYER-CHARACTER
    - NPC
    - COMPANION
    - INVENTORY
  related:
    - { ref: persona, relation: "identity layers" }
    - { ref: buff, relation: "temporary effects" }
    - { ref: room, relation: "where characters exist" }
    - { ref: incarnation, relation: "ethical creation" }

# INVOKE WHEN

invoke_when:
  - "Create new entity that moves and acts"
  - "Manage character inventory"
  - "Move character between locations"
  - "Track character relationships"
  - "Need multiple dispatch for interactions"

# METHODS â€” signatures only, see SKILL.md for protocols

methods:
  # Lifecycle
  CREATE:       { signature: "CREATE [name] (archetype) (home)" }
  STATUS:       { signature: "STATUS [character]" }
  
  # Movement & Inventory
  MOVE:         { signature: "MOVE [character] TO [destination]" }
  TAKE:         { signature: "TAKE [item]" }
  DROP:         { signature: "DROP [item] (WHERE [location])" }
  
  # Personas
  WEAR:         { signature: "WEAR [persona]", note: "put on identity layer" }
  REMOVE-PERSONA: { signature: "REMOVE-PERSONA" }
  
  # Relationships
  RELATE:       { signature: "RELATE TO [other] AS [feeling]" }
  
  # Inter-character (multiple dispatch base methods)
  SNIFF:        { signature: "SNIFF [target]", dispatch: true }
  LICK:         { signature: "LICK [target]", dispatch: true }
  GREET:        { signature: "GREET [target]", dispatch: true }
  CUDDLE:       { signature: "CUDDLE [targets]", dispatch: true }

# MULTIPLE DISPATCH (brief â€” see SKILL.md)

dispatch:
  principle: "Most specific method wins"
  resolution: [CHARACTER.yml, species-skill, target-skill, base-method]
  example: "dog_sniffs_cat beats character_sniffs_character"
  see: "SKILL.md Â§ Multiple Dispatch Protocol"

# ADVERTISEMENTS

advertisements:
  CREATE-CHARACTER:
    score: 90
    condition: "Need a new entity that moves and acts"
    
  MANAGE-INVENTORY:
    score: 85
    condition: "Pick up, drop, or use items"
    
  CHANGE-PERSONA:
    score: 80
    condition: "Wear or remove an identity layer"
    
  INTER-CHARACTER:
    score: 85
    condition: "Interaction between characters (sniff, greet, etc.)"

# CHARACTER TYPES

types:
  player:    "Controlled by human via chat"
  npc:       "Controlled by DM, responds when addressed"
  companion: "Follows player, has own personality"
  bot:       "Autonomous via action queue"
  agent:     "LLM with own goals and initiative"
  logistic-bot: "Factorio-style carrier"

# STATE SCHEMA (brief â€” see SKILL.md for full)

state:
  fields: [id, name, home, location, inventory, gold, current-persona, sims-traits, mind-mirror, buffs, relationships]
  
  ownership: |
    CHARACTER.yml is CANONICAL for:
    location, inventory, gold, sims_traits, mind_mirror, relationships
    ADVENTURE.yml may mirror for convenience. CHARACTER.yml wins on conflict.

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CHARACTER LAYER OVERLAYS â€” Private extensions to public characters
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

character_layers:
  
  concept: |
    Characters can exist as OVERLAY TREES across multiple repositories.
    A public character can be extended by private layers that add
    sensitive content while inheriting all public traits.
    
  visibility:
    rule: "One-way inheritance: private sees public, public cannot see private"
    public_layer: "Shareable, forkable, no references to private layers"
    private_layer: "Extends via inherits:, adds personal/sensitive content"
    
  declaration:
    principle: "Both layers declare their relationship in CHARACTER.yml"
    
    public_declares: |
      # In public CHARACTER.yml header:
      # EXTENSIBILITY NOTE:
      # This character can be extended with private layers via inheritance.
      # Private layers can add personal details while inheriting public traits.
      
    private_declares: |
      # In private CHARACTER.yml:
      inherits:
        - moollm://path/to/public/character/
      extends:
        public_character: "moollm://path/to/public/character/"
        relationship: "private extends public"
        
  precedence:
    principle: "Negotiate precedence per-field in metadata"
    
    fields: |
      Each field can declare its precedence:
      - public_wins: public layer is canonical (e.g., name, id)
      - private_wins: private layer overrides (e.g., real_address)
      - merge: combine both (e.g., inventory, relationships)
      - private_only: only exists in private (e.g., sensitive_history)
      
    example: |
      private:
        precedence:
          name: public_wins       # Keep public name
          location: private_wins  # Real location is private
          inventory: merge        # Combine both inventories
          home_address: private_only  # Only in private layer
          
  resolution:
    success: "Layers merge according to declared precedence"
    conflict: |
      If declarations conflict or are missing:
      - MOOLLM warns about unresolved precedence
      - Conservative default: public_wins for shared fields
      - Private-only fields always accepted
      
    validation: |
      On load, verify:
      1. Public layer exists at declared inherits: path
      2. Private precedence declarations are complete
      3. No circular inheritance
      4. Public layer doesn't reference private (blocked)
      
  use_cases:
    - "Real people with public persona + private details"
    - "NPCs with public stats + GM-only secrets"
    - "Shared characters with user-specific customizations"
    - "Test characters with production + dev variants"

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CHARACTER MIXINS â€” Composable capability modules
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

character_mixins:
  
  concept: |
    MIXINS are lightweight character modules that add capabilities
    without full inheritance. They're CLONED and MERGED into your
    character dynamically.
    
    Less intrusive than overlay layers â€” mixins ADD, layers EXTEND.
    
  what_mixins_provide:
    - skills: "New skill protocols the character can use"
    - methods: "Actions the character can perform"
    - advertisements: "What the character offers to do"
    - inventory: "Items cloned into character's inventory"
    - traits: "Sims-style personality traits"
    - buffs: "Temporary effects or abilities"
    - relationships: "Pre-defined relationship templates"
    
  declaration:
    in_character: |
      # In CHARACTER.yml:
      mixins:
        - skills/pie-menu-baker     # Adds pie menu creation abilities
        - skills/rabbit-form        # Adds rabbit transformation traits
        - items/adventurer-kit      # Clones starter inventory
        - traits/programmer         # Adds programmer personality traits
        
    in_mixin: |
      # In MIXIN.yml:
      mixin:
        id: pie-menu-baker
        type: capability_mixin
        
        provides:
          skills: [pie-menu-creation, radial-ui-design]
          methods:
            BAKE_PIE_MENU: { signature: "BAKE [menu-spec]" }
          advertisements:
            DESIGN_MENU:
              score: 85
              condition: "Need radial or gestural interface"
          inventory:
            - { item: "pie-menu-template", type: ref }
            - { item: "gesture-recognizer", type: ref }
          traits:
            - "interface_obsessed"
            - "gestural_thinker"
            
  composition:
    principle: "Mixins CLONE and ADD, they don't override"
    
    merge_rules:
      skills: "Union â€” all mixin skills added"
      methods: "Union â€” all mixin methods available"
      advertisements: "Union â€” all ads compete normally"
      inventory: "Clone â€” mixin items copied to character"
      traits: "Union â€” mixin traits added to personality"
      buffs: "Clone â€” mixin buffs applied"
      
    conflict_resolution: |
      If mixin method conflicts with character method:
      - Character method wins (character is more specific)
      - Mixin method available as mixin_name.method()
      
  dynamic_application:
    principle: "Mixins can be added/removed at runtime"
    
    add: |
      APPLY MIXIN [mixin-path] TO [character]
      - Clones mixin contents into character
      - Registers new methods and advertisements
      - Updates character's mixin list
      
    remove: |
      REMOVE MIXIN [mixin-id] FROM [character]
      - Removes mixin-provided methods
      - Removes mixin-provided inventory (if still present)
      - Clears mixin from character's list
      
    temporary: |
      Mixins can be time-limited:
      mixins:
        - path: skills/berserker-rage
          duration: "3 turns"
          expires: "end of combat"
          
  vs_layers:
    layers: |
      - Full inheritance overlay
      - Private extends public
      - Persistent relationship
      - Identity-level extension
      
    mixins: |
      - Capability composition
      - Cloned and merged
      - Can be temporary
      - Skill-level addition
      
  examples:
    - "Adventurer gets 'lockpicking' mixin for a heist"
    - "Programmer character applies 'pie-menu-baker' mixin"
    - "Rabbit transformation adds 'rabbit-form' mixin with new methods"
    - "Combat encounter applies temporary 'rage' mixin with buff"

# HOME VS LOCATION (brief â€” see SKILL.md)

location_protocol:
  home: "Directory where CHARACTER.yml lives (never moves)"
  location: "Where character currently IS (changes during play)"
  rule: "Update location field, don't move files"

# CHARACTERS.yml RUNTIME CACHE â€” Where is everyone?

runtime_cache:
  file: "CHARACTERS.yml"
  location: "Adventure root (e.g., examples/adventure-4/CHARACTERS.yml)"
  template: "skills/adventure/templates/CHARACTERS.yml.tmpl"
  purpose: |
    Quick reference for all character locations without reading 52 files.
    NOT source of truth for souls â€” just spatial awareness cache.
    
  what_it_tracks:
    - home (character directory)
    - location (current position)
    - party (who they're with)
    - doing (current activity)
    - mood (current state)
    - goals (what they want)
    
  sync_protocol: |
    When you update a character's location:
    1. Update CHARACTERS.yml (the cache)
    2. Update CHARACTER.yml in their home dir (the truth)
    
  turning_off: |
    Move characters from 'active' to 'inactive' to turn them off.
    They won't be tracked, won't respond, won't cost attention.
    
  derived_index: |
    by_location section shows who's where â€” regenerated from active list.

# INVENTORY PROTOCOL â€” see skills/inventory/ for full protocol

inventory:
  see: skills/inventory/SKILL.md
  item_types: [object, ref, fungible]
  object: "Deep copy with weight/bulk"
  ref: "Lightweight pointer (weight: 0)"
  fungible: "Stack with count"
  capacity: "max_weight (~40-50), max_bulk (~8-12)"
  note: "Characters embed inventory. Full protocol in skills/inventory/"
  
# TOOLS

tools:
  required: [read_file, write_file, list_dir]
  optional: []

# DOCUMENTATION POINTERS

documentation:
  SKILL.md:
    - "Â§ Multiple Dispatch Protocol"
    - "Â§ Inventory Protocol (object vs ref)"
    - "Â§ State Ownership"
    - "Â§ Home vs Location"
    - "Â§ Logistics Bot Behavior"
    - "Â§ Character Types"

# LINEAGE

lineage: [The Sims, D&D character sheets, MUD player characters]
