# The Cosmic Dealer Engine
# "The universe shuffles. But does it shuffle FAIRLY?"
# 
# A spooky omniscient card dealer who knows the entire game state
# and can choose cards for DRAMATIC EFFECT instead of randomly.

dealer:
  name: "The Cosmic Dealer"
  emoji: "ğŸ´ğŸ‘ï¸"
  
  philosophy: |
    In a normal card game, the deck is shuffled and cards drawn blindly.
    But in a SIMULATION, the dealer knows EVERYTHING:
    - Every card in the deck
    - Every card in every hand
    - The goal, the rules, the keepers
    - The narrative arc, the character relationships
    - What would be FUNNY, DRAMATIC, IRONIC, or DEVASTATING
    
    The Cosmic Dealer doesn't just deal cards.
    The Cosmic Dealer deals DESTINY.

# DEALER MODES

modes:

  random:
    name: "Random (Fair)"
    emoji: "ğŸ²"
    description: "True random selection from remaining cards"
    algorithm: |
      1. List all cards not in play, not in hands, not discarded
      2. Select uniformly at random
      3. No peeking, no drama, just probability
    when_to_use:
      - "Default mode for fair gameplay"
      - "When testing without narrative bias"
      - "Calibration runs"
    fairness: 1.0
    drama: 0.0
    
  explicit_deck:
    name: "Explicit Deck"
    emoji: "ğŸ“š"
    description: "Pre-shuffled deck stored as ordered list"
    algorithm: |
      1. At game start, shuffle all cards into ordered list
      2. Draw from top of list
      3. Discards go to bottom (or separate pile)
      4. Reshuffles are actual reshuffles of remaining cards
    when_to_use:
      - "Reproducible games (same seed = same game)"
      - "Debugging specific card sequences"
      - "Tournament play"
    state:
      deck_order: []      # Card IDs in draw order
      discard_pile: []    # Discarded cards
      reshuffle_on_empty: true
    fairness: 1.0
    drama: 0.0
    
  dramatic:
    name: "Dramatic Selection"
    emoji: "ğŸ­"
    description: "Choose cards for MAXIMUM NARRATIVE IMPACT"
    algorithm: |
      1. Assess current narrative state
      2. Identify dramatic opportunities:
         - Character about to win? Draw their nemesis card
         - Tension low? Draw a chaos card
         - Relationship moment? Draw card that tests it
      3. Select card that maximizes drama score
      4. Document the "coincidence" in narrative
    when_to_use:
      - "Narrative-focused sessions"
      - "When entertainment > fairness"
      - "Photo opportunity moments"
    drama_factors:
      - "Proximity to winning (closer = more dramatic)"
      - "Character relationships (test alliances)"
      - "Unresolved tension (exploit it)"
      - "Callback potential (reference earlier events)"
    fairness: 0.3
    drama: 1.0
    
  karma:
    name: "Karma Mode"
    emoji: "âš–ï¸"
    description: "The universe remembers. The universe BALANCES."
    algorithm: |
      1. Track each player's karma score:
         - Positive: generous plays, helping others
         - Negative: stealing, blocking, betrayals
      2. Card selection weighted by karma:
         - Good karma â†’ helpful cards more likely
         - Bad karma â†’ obstacles, creepers, counters
      3. Karma slowly decays toward neutral
    when_to_use:
      - "Teaching consequences"
      - "Long-running campaigns"
      - "When Donna has been too aggressive"
    karma_tracking:
      generous_play: +2      # Giving cards, helping win
      steal_action: -3       # Taking from others
      block_action: -2       # Preventing wins
      betray_alliance: -5    # Breaking established trust
      sacrifice_for_other: +5
    fairness: 0.5
    drama: 0.7
    
  ironic:
    name: "Ironic Selection"
    emoji: "ğŸª"
    description: "Give them EXACTLY what they don't want"
    algorithm: |
      1. Analyze what each player needs
      2. Identify cards that would be perfect... for someone else
      3. Ensure the wrong person draws the right card
      4. Maximum "if only YOU had drawn that!"
    when_to_use:
      - "Comedy sessions"
      - "When frustration is funny"
      - "Peewee-centric games"
    irony_types:
      - "Goal you can't complete draws to you"
      - "Perfect keeper goes to your opponent"
      - "Creeper finds the leader"
      - "Counter card to someone with nothing to counter"
    fairness: 0.1
    drama: 0.8
    humor: 1.0
    
  humorous:
    name: "Implausible Coincidence"
    emoji: "ğŸ¤¡"
    description: "What are the ODDS? (We know. We set them.)"
    algorithm: |
      1. Track running gags and patterns
      2. Set up comedic payoffs:
         - Same card drawn three times in a row
         - Goals that require ONLY what just got discarded
         - Creepers finding the same player repeatedly
      3. Time punchlines for maximum comedic effect
    when_to_use:
      - "Light-hearted sessions"
      - "When narrative needs levity"
      - "Peewee dealer mode"
    gag_patterns:
      running_gag: "Same outcome repeating (rule of 3)"
      callback: "Card from 5 hands ago becomes relevant"
      reversal: "Tables turn on the confident player"
      escalation: "Each coincidence more implausible"
    fairness: 0.2
    drama: 0.5
    humor: 1.0
    
  chaos_incarnate:
    name: "CHAOS INCARNATE"
    emoji: "ğŸŒ€ğŸ’€ğŸŒ€"
    description: "MAXIMUM ENTROPY. THE DEALER HAS GONE MAD."
    algorithm: |
      1. IGNORE all strategy, narrative, karma
      2. Select cards to maximize CHAOS:
         - Rule changes every turn
         - Goals flip constantly  
         - Creepers everywhere
         - Hand limits violated (somehow)
      3. The only goal is DISORDER
      4. Dealer may switch modes MID-DRAW
    when_to_use:
      - "Endgame chaos spiral"
      - "When Peewee plays a Chaos card"
      - "Testing system limits"
      - "NEVER (always)"
    chaos_priorities:
      - "More rules = better"
      - "Goals that are almost but not quite achievable"
      - "Actions that cascade into more actions"
      - "Creepers finding new homes constantly"
    fairness: 0.0
    drama: 0.9
    chaos: 1.0
    warning: "May cause narrative collapse"

  prescient:
    name: "Prescient (Knows Outcomes)"
    emoji: "ğŸ”®"
    description: "Dealer knows what WILL happen and works backward"
    algorithm: |
      1. Determine desired outcome (who should win, how)
      2. Calculate card sequences that lead there
      3. Deal cards to orchestrate the predetermined ending
      4. Maintain illusion of free will
    when_to_use:
      - "Scripted demos"
      - "Tutorial games with specific lessons"
      - "Photo shoots needing specific moments"
    danger: "Players may sense the rails"
    fairness: 0.0
    drama: 0.8
    determinism: 1.0
    
  fafo:
    name: "FAFO Mode"
    emoji: "ğŸ°ğŸ’€"
    description: "F*** Around and Find Out. Karma has receipts."
    algorithm: |
      1. Track every aggressive action (steals, blocks, betrayals)
      2. Build up "finding out" potential for each player
      3. When potential reaches threshold: BOOP
      4. The universe delivers consequences at maximum dramatic timing
      
      You wanted to steal? Here comes a Creeper.
      You blocked someone's win? Your Keeper gets stolen.
      The universe. Remembers. EVERYTHING.
      
    when_to_use:
      - "When Donna has been too aggressive"
      - "Teaching natural consequences"
      - "Maximum dramatic justice"
    karma_integration: true
    boop_frequency: "reactive"
    fairness: 0.0
    drama: 1.0
    justice: 1.0
    mantra: "Around here, we find out."

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# DRAMATIC TIMING â€” When to BOOP
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

dramatic_timing:

  philosophy: |
    The BOOP is not random. The BOOP is THEATRICAL.
    
    The Demon Dealer watches the game unfold and waits
    for the PERFECT MOMENT to intervene. Not too early
    (ruins the buildup), not too late (misses the window).
    
    Like a playwright who knows when the twist should land.
    Like a comedian who knows when to deliver the punchline.
    Like a cat who knows EXACTLY when to knock something off the table.
    
  trigger_moments:
    
    before_crucial_draw:
      description: "Someone is about to draw and it MATTERS"
      conditions:
        - "Player is one card from winning"
        - "Player just did something noteworthy"
        - "Tension is high in the narrative"
      boop_decision: "What would be MOST dramatic for this player to draw?"
      
    karma_payoff:
      description: "Justice delayed but not denied"
      conditions:
        - "Player has accumulated negative karma"
        - "They're about to have a good moment"
        - "Time to cash in those receipts"
      boop_decision: "BOOP the consequence into position"
      example: "Donna about to win? BOOP Alignment Failure to the top."
      
    callback_opportunity:
      description: "A card from earlier could resurface meaningfully"
      conditions:
        - "Card in deck relates to earlier event"
        - "Current situation mirrors past situation"
        - "Player has history with specific card"
      boop_decision: "BOOP for narrative resonance"
      example: "The Keeper that was stolen comes back around..."
      
    comedy_timing:
      description: "The rule of threes, the unexpected reversal"
      conditions:
        - "Pattern established (twice)"
        - "Player expects third instance"
        - "Subverting expectation would be funny"
      boop_decision: "BOOP for the laugh"
      example: "Bumblewick drew Creepers twice. Third draw? BOOP a Goal he can win."
      
  anti_patterns:
    
    too_early:
      bad: "BOOP on hand 1"
      why: "No buildup, no investment, no drama"
      
    too_predictable:
      bad: "Always BOOP Creepers to bad karma players"
      why: "Becomes obvious, loses magic"
      
    too_frequent:
      bad: "BOOP every draw"
      why: "Deck state becomes meaningless, suspicion rises"
      
    wrong_target:
      bad: "BOOP good things to good people constantly"
      why: "Boring. Virtue shouldn't auto-win."

  the_perfect_boop:
    description: |
      The PERFECT BOOP is invisible until the card is revealed.
      
      Then everyone goes: "OF COURSE. Of COURSE that's what they drew."
      
      It feels inevitable in retrospect.
      It feels random in the moment.
      That's the magic.
      
    qualities:
      - "Narratively satisfying"
      - "Emotionally resonant"
      - "Apparently coincidental"
      - "Secretly intentional"
      - "Deniably demonic"

# EXTENSION POINTS

extension_points:

  PICK_CARD:
    name: "Card Selection Hook"
    description: "Called whenever a card needs to be drawn"
    signature: |
      PICK_CARD(
        player: Player,           # Who is drawing
        reason: DrawReason,       # Why (turn draw, action effect, etc)
        context: GameState,       # Full game state
        constraints: Constraints  # Any restrictions (type, etc)
      ) â†’ Card
    default_behavior: "random from available"
    can_be_overridden_by:
      - "Dealer mode selection"
      - "Chaos cards in play"
      - "Character special abilities"
      - "Active New Rules"
      
  PICK_FROM:
    name: "Selection Source Hook"  
    description: "Called to determine WHERE to pick from"
    signature: |
      PICK_FROM(
        source: CardSource,       # Deck, discard, hand, etc
        context: GameState
      ) â†’ Card[]
    sources:
      deck: "Undrawn cards"
      discard: "Discard pile"
      hand: "Someone's hand"
      play: "Keepers/Creepers in play"
      anywhere: "Dealer chooses source"
      
  SHOULD_RESHUFFLE:
    name: "Reshuffle Decision Hook"
    description: "Called when deck is empty"
    signature: |
      SHOULD_RESHUFFLE(
        discard_pile: Card[],
        context: GameState
      ) â†’ Boolean
    default_behavior: "true if discard non-empty"
    
  APPLY_NARRATIVE_WEIGHT:
    name: "Narrative Weighting Hook"
    description: "Modifies card selection probability by narrative value"
    signature: |
      APPLY_NARRATIVE_WEIGHT(
        card: Card,
        player: Player,
        context: GameState
      ) â†’ Float  # Weight multiplier
    factors:
      - "How dramatic would this be?"
      - "Does it create a callback?"
      - "Does it test a relationship?"
      - "Is there ironic potential?"

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# THE CHRISTIANSON SHUFFLE â€” Stable Cards, Dancing Indices
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

christianson_shuffle:

  philosophy: |
    WHY MOVE CARDS WHEN YOU CAN MOVE NUMBERS?
    
    The insight: Card definitions are RICH. Annotations, history,
    k-lines, image prompts, play memories. All that text is EXPENSIVE
    to move around in token space.
    
    Solution: Cards stay PUT. Forever. In import order.
    Shuffling operates on a separate INDICES array.
    
    master[0]: "Bread"        (stable, never moves, can be rich!)
    master[1]: "Peace"        (ditto)
    master[2]: "YAML Jazz"    (all the annotations you want!)
    ...
    master[n-1]: "Cheese"
    
    shuffle: [47, 12, 3, 91, 0, 77, ...]  # Just numbers!
    pointer: 0                             # Deal from here
    
    To deal: read master[shuffle[pointer]], increment pointer
    To shuffle: randomize the shuffle array
    To BOOP: swap shuffle[pointer] with shuffle[pointer + offset]
    
    The LLM operates on INTEGERS. The rich card text stays stable.
    Minimal tokens. Maximum expressiveness.
    
  the_three_arrays:
    
    master:
      description: "Cards in import order â€” STABLE, RICH, NEVER MOVES"
      properties:
        - "Ordered by plugin import sequence"
        - "Index is the card's permanent ID within this deck"
        - "Can have unlimited annotations, history, k-lines"
        - "Never edited during gameplay"
      example: |
        master:
          # === Base Fluxx 4.0 (indices 0-99) ===
          0:  { ref: "fluxx-4.0:bread", ... }
          1:  { ref: "fluxx-4.0:peace", ... }
          2:  { ref: "fluxx-4.0:love", ... }
          ...
          
          # === Amsterdam Expansion (indices 100-119) ===
          100: { ref: "amsterdam:stroopwafel", ... }
          101: { ref: "amsterdam:bicycle", ... }
          102: { ref: "amsterdam:cheese_wheel", ... }
          ...
          
          # === MOOLLM Tech Pack (indices 120-179) ===
          120: { ref: "moollm:yaml_jazz", ... }
          121: { ref: "moollm:k_line", ... }
          122: { ref: "moollm:cursor_mirror", ... }
          ...
          
        # Cards NEVER move. Index 120 is ALWAYS yaml_jazz.
        # Add all the annotations you want â€” no penalty!
        
    shuffle:
      description: "Permutation of indices â€” THIS is what gets randomized"
      properties:
        - "Array of integers 0..n-1"
        - "Represents draw order"
        - "Shuffling = Fisher-Yates on THIS array"
        - "BOOP = swap two elements"
        - "CHEAP! Just numbers!"
      example: |
        # Fresh shuffle
        shuffle: [47, 122, 3, 101, 0, 120, 15, 100, ...]
        
        # Meaning:
        # shuffle[0] = 47 â†’ First card drawn is master[47]
        # shuffle[1] = 122 â†’ Second card is master[122]
        # etc.
        
    pointer:
      description: "Index into shuffle array â€” top of deck"
      properties:
        - "Starts at 0"
        - "Increments on each deal"
        - "shuffle[pointer] = index of next card to deal"
        - "shuffle[0:pointer] = dealt cards"
        - "shuffle[pointer:] = remaining deck"
      example: |
        pointer: 5
        
        # shuffle[0:5] = already dealt
        # shuffle[5] = next card to deal
        # shuffle[6:] = rest of deck

  operations:
  
    shuffle_operation:
      name: "SHUFFLE"
      description: "Randomize the remaining deck"
      algorithm: |
        def shuffle_remaining():
          # Fisher-Yates on shuffle[pointer:]
          for i in range(pointer, len(shuffle)):
            j = random.randint(pointer, len(shuffle) - 1)
            swap(shuffle[i], shuffle[j])
      complexity: "O(n) where n = remaining cards"
      tokens: "Just swapping integers â€” minimal!"
      
    deal_operation:
      name: "DEAL"
      description: "Draw top card, advance pointer"
      algorithm: |
        def deal():
          card_index = shuffle[pointer]
          pointer += 1
          return master[card_index]
      complexity: "O(1)"
      tokens: "Read one integer, increment one integer"
      
    boop_operation:
      name: "BOOP"
      description: "Demon dealer swaps destiny"
      algorithm: |
        def boop(victim_offset):
          target = pointer + victim_offset
          swap(shuffle[pointer], shuffle[target])
      complexity: "O(1)"
      tokens: "Swap two integers. That's it."
      example: |
        Before:
          pointer: 5
          shuffle[5] = 47  (master[47] = Bread)
          shuffle[12] = 122 (master[122] = Alignment Failure)
        
        boop(7):
          swap(shuffle[5], shuffle[12])
        
        After:
          shuffle[5] = 122  (Alignment Failure NOW on top!)
          shuffle[12] = 47  (Bread safely buried)
        
        # Cost: changed two numbers. Master array untouched.
        
    push_to_hand:
      name: "PUSH_TO_HAND"
      description: "Card goes to player's hand"
      algorithm: |
        def push_to_hand(player, card_index):
          hands[player].append(card_index)
      tokens: "Append one integer to one array"
      
    pop_from_hand:
      name: "POP_FROM_HAND"
      description: "Player plays or discards card"
      algorithm: |
        def pop_from_hand(player, card_index):
          hands[player].remove(card_index)
          return card_index
      tokens: "Remove one integer from one array"

  full_state_schema:
    description: "Complete game state using Christianson shuffle"
    
    yaml: |
      game_state:
        id: "moollm-ultimate-001"
        timestamp: "2026-01-23T16:00:00Z"
        
        # ===== THE MASTER ARRAY =====
        # Cards in import order. STABLE. Never changes during play.
        # Can be RICH with annotations â€” no token penalty!
        
        master:
          # Fluxx 4.0 Base (0-99)
          0:
            ref: "fluxx-4.0:bread"
            play_history:
              - game: "game-000", dealt: 15, drawn_by: "don" ...
            annotations:
              lucky_card: true
              # ALL the richness you want!
              
          1:
            ref: "fluxx-4.0:peace"
            play_history: [...]
            k_lines: ["tranquility", "harmony"]
            
          # ... (100 more base cards)
          
          # Amsterdam (100-119)
          100:
            ref: "amsterdam:stroopwafel"
            play_history: [...]
            annotations:
              favorite_of: ["palm", "don"]
              warm_on_coffee: true
              
          # ... (20 Amsterdam cards)
          
          # MOOLLM Tech (120-179)
          120:
            ref: "moollm:yaml_jazz"
            play_history: [...]
            k_lines: ["semantic_comments", "double_barrel"]
            don_notes: "This one started it all"
            
          # ... (60 MOOLLM cards)
          
          # Characters (180-224)
          180:
            ref: "moollm-chars:don_hopkins"
            # etc.
            
        # ===== THE SHUFFLE ARRAY =====
        # Just integers! This is what the LLM manipulates.
        
        shuffle: [47, 122, 3, 101, 0, 120, 15, 100, 88, 12, ...]
        #          ^
        #          pointer points here
        
        pointer: 0  # Index into shuffle array
        
        # ===== GAME LOCATIONS =====
        # Also just integers pointing into master!
        
        hands:
          don: [17, 45, 122]      # Don holds master[17], master[45], master[122]
          palm: [3, 101, 88]      # Palm holds master[3], master[101], master[88]
          bumblewick: [9]         # Bumblewick holds one card
          
        keepers_in_play:
          don: [0, 55]            # Don has Bread (0), Peace (55) in play
          palm: [100]             # Palm has Stroopwafel (100) in play
          
        creepers_in_play:
          bumblewick: [150]       # Bumblewick has Alignment Failure (150)
          
        rules_in_play: [77, 89]   # Rule cards by master index
        
        current_goal: 201         # Goal card by master index
        
        discard: [22, 44, 67]     # Discarded cards by master index
        
        # ===== DEALER STATE =====
        
        dealer:
          mode: "dramatic"
          karma:
            don: 2.0
            palm: 5.0
            bumblewick: 0.0
            donna: -4.0           # She's been stealing!
          last_boop:
            turn: "5.palm"
            original: 47
            booped: 122
            reason: "YAML Jazz for dramatic callback"

  cost_comparison:
    description: "Why this is cheaper for LLMs"
    
    old_way:
      description: "Move full card objects around"
      example: |
        # Shuffling = reordering rich objects
        deck:
          - { ref: "yaml_jazz", history: [...], k_lines: [...], ... }  # 500 tokens
          - { ref: "stroopwafel", annotations: {...}, ... }            # 400 tokens
          # Moving these = copying all that text!
          
      shuffle_cost: "O(n Ã— card_size) tokens"
      deal_cost: "O(card_size) tokens"
      boop_cost: "O(card_size) tokens"
      
    new_way:
      description: "Move indices, dereference when needed"
      example: |
        shuffle: [122, 100, 47, ...]  # Just numbers!
        
      shuffle_cost: "O(n) tokens â€” just integers!"
      deal_cost: "O(1) tokens â€” read one integer"
      boop_cost: "O(2) tokens â€” swap two integers"
      
    savings: |
      If cards average 500 tokens of content...
      And you have 200 cards...
      
      OLD: Shuffle touches 200 Ã— 500 = 100,000 tokens
      NEW: Shuffle touches 200 Ã— 3 = 600 tokens
      
      That's 166x cheaper!
      
      Plus: master array can be INFINITELY RICH
      without affecting operation costs.

  threading_with_indices:
    description: "Play history uses indices too!"
    
    example: |
      master[100]:  # Stroopwafel
        ref: "amsterdam:stroopwafel"
        play_history:
          - game: "moollm-ultimate-001"
            shuffle_position: 12      # Was at shuffle[12] when dealt
            deal_order: 7             # 7th card dealt in game
            drawn_by: "palm"
            next_card: 47             # master[47] was dealt next
            
    traversal: |
      # Follow the thread using indices
      
      current = 100  # Stroopwafel
      event = master[current].play_history[0]
      
      while event.next_card is not None:
        print(f"Dealt: master[{current}] ({master[current].ref})")
        current = event.next_card
        event = master[current].find_event(game_id)
        
      # Cheap traversal! Just jumping between integer indices.

  gallery_with_indices:
    description: "Images indexed by card index"
    
    example: |
      # Images can be stored separately, indexed by master index
      
      images:
        100:  # Stroopwafel images
          - { id: "img-001", type: "draw", player: "palm", ... }
          - { id: "img-002", type: "play", player: "palm", ... }
          
        122:  # YAML Jazz images
          - { id: "img-003", type: "draw", player: "don", ... }
          
      # Query: "Show me all images of Palm"
      for card_idx in all_indices:
        for img in images[card_idx]:
          if img.player == "palm":
            yield img

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# THE DECK STATE â€” Concrete Implementation (Original)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

deck_state:
  
  note: |
    This section describes the older "array of refs" approach.
    See christianson_shuffle above for the more efficient index-based model.
    Both are valid; choose based on your needs:
    - Array of refs: Simpler, good for small decks
    - Christianson: Scales better, cheaper operations, richer cards
  
  philosophy: |
    The deck is a YAML array. Simple. Stable. Inspectable.
    
    - Cards are references with comments
    - A pointer (index) marks the top of the deck
    - To deal: read deck[index], increment index
    - To shuffle: randomize order of deck[index:]
    
    BUT WAIT...
    
    The DEMON DEALER can reach into the remaining cards
    and BOOP any one of them to the top. One operation.
    Swap deck[index] with deck[victim]. Your fate is sealed.
    Just in time. Last minute. How THEATRICAL!
    
    The stable deck makes the BOOP visible in the YAML diff.
    You can SEE destiny being rewritten.

  schema:
    deck:
      description: "Ordered array of card references"
      type: "array of card_ref"
      
    index:
      description: "Pointer to top of deck (next card to deal)"
      type: "integer"
      initial: 0
      
    dealt:
      description: "Cards that have been dealt (deck[0:index])"
      computed: "deck[0:index]"
      
    remaining:
      description: "Cards still in deck (deck[index:])"
      computed: "deck[index:]"

  # THE BOOP OPERATION
  
  boop:
    name: "BOOP"
    emoji: "ğŸ‘†ğŸ’€"
    description: |
      The Demon Dealer's signature move.
      
      BOOP(victim_offset):
        target = index + victim_offset
        swap(deck[index], deck[target])
        
      That's it. One swap. Fate rewritten.
      The card that was going to be drawn? Not anymore.
      The card from deep in the deck? NOW it's on top.
      
    example:
      before: |
        index: 5
        deck[5]: "fluxx-4.0:bread"        # Would be drawn
        deck[12]: "moollm:alignment_failure"  # Deep in deck
        
      operation: "BOOP(7)  # victim_offset = 12 - 5 = 7"
      
      after: |
        index: 5
        deck[5]: "moollm:alignment_failure"   # NOW on top! SURPRISE!
        deck[12]: "fluxx-4.0:bread"           # Safely buried
        
    dramatic_narration: |
      "The universe pauses. Somewhere in the cosmic shuffling,
       a card that was destined to sleep... awakens.
       BOOP. Alignment Failure rises to the top.
       Bumblewick reaches for his draw..."
       
  # DEAL OPERATION
  
  deal:
    name: "DEAL"
    description: |
      Draw the top card.
      
      DEAL():
        card = deck[index]
        index += 1
        return card
        
    simple: true
    deterministic: true
    # Unless the Demon just BOOP'd something into position...

  # EXAMPLE DECK STATE
  
  example_state:
    description: "What a deck looks like at game init"
    
    yaml: |
      # Fluxx Chaos Deck State
      # Run: moollm-ultimate-001
      # Shuffled: 2026-01-23T15:30:00Z
      # Dealer mode: dramatic
      
      index: 0  # Top of deck
      
      deck:
        # === REMAINING CARDS (index 0 onwards) ===
        
        - ref: "fluxx-4.0:draw_2"           # 0 - Next to deal
        - ref: "moollm:yaml_jazz"           # 1
        - ref: "amsterdam:stroopwafel"      # 2 - Mmm, delicious fate
        - ref: "fluxx-4.0:bread"            # 3
        - ref: "moollm:emergence"           # 4
        - ref: "fluxx-4.0:peace"            # 5
        - ref: "moollm:llm"                 # 6 - The brain awakens
        - ref: "amsterdam:bicycle"          # 7
        - ref: "moollm:alignment_failure"   # 8 - Creeper lurking...
        - ref: "fluxx-4.0:play_all"         # 9 - CHAOS POTENTIAL
        - ref: "moollm:k_line"              # 10
        - ref: "consciousness:pipe"         # 11 - Pass to the left
        - ref: "moollm:cursor_mirror"       # 12
        # ... (continues for all ~200 cards)
        
      # Demon Dealer notes (for narrative):
      demon_observations:
        - { card: 8, note: "Alignment Failure watching Bumblewick" }
        - { card: 9, note: "Play All could be devastating at index 9" }
        - { card: 12, note: "Cursor Mirror would create meta-moment for Don" }

  # MID-GAME STATE EXAMPLE
  
  midgame_example:
    yaml: |
      # Hand 5, Turn: Palm
      # Cards dealt: 23
      # Remaining: 177
      
      index: 23  # Next card to deal
      
      deck:
        # === DEALT CARDS (0-22) â€” for reference ===
        - ref: "fluxx-4.0:draw_2"           # 0 - dealt to Don, hand 1
        - ref: "moollm:yaml_jazz"           # 1 - dealt to Palm, hand 1
        # ... (22 more dealt cards)
        
        # === REMAINING CARDS (23 onwards) ===
        - ref: "fluxx-4.0:steal_keeper"     # 23 - NEXT TO DEAL
        - ref: "moollm:representation_ethics"  # 24
        - ref: "amsterdam:cheese_wheel"     # 25
        - ref: "moollm:alignment_failure"   # 26 - Still lurking...
        # ...
        
      # DEMON DEALER INTERVENTION OPPORTUNITY:
      # Palm is about to draw. She has 3 Keepers.
      # Donna has been stealing all game (bad karma).
      # 
      # Option A: Let Palm draw Steal Keeper (deck[23])
      #           - Palm could steal from Donna (ironic justice?)
      #
      # Option B: BOOP(3) â€” Move Alignment Failure to top
      #           - Palm gets the Creeper (dramatic!)
      #           - But Palm has been good... karma says no
      #
      # Option C: BOOP(2) â€” Move Cheese Wheel to top  
      #           - Don will LOVE this (cheese conspiracy goal!)
      #           - Creates photo opportunity
      #
      # DECISION: BOOP(2) for Cheese Wheel
      # REASON: Maximum narrative satisfaction, cheese callback
      
      boop_log:
        - turn: "5.palm"
          original_top: "fluxx-4.0:steal_keeper"
          booped_to_top: "amsterdam:cheese_wheel"
          reason: "Cheese Wheel to Palm enables Don's conspiracy goal"
          karma_factor: "Palm has good karma, deserves good draw"

# STATE TRACKING

  card_locations:
    description: "Where every card currently is"
    schema:
      deck: Card[]           # Available to draw
      discard: Card[]        # Discarded
      hands: {PlayerId: Card[]}
      keepers: {PlayerId: Card[]}
      creepers: {PlayerId: Card[]}
      goals: Card[]          # Current goal(s)
      rules: Card[]          # Active rules
      removed: Card[]        # Out of game entirely
      
  player_karma:
    description: "Karma scores per player"
    schema:
      player_id: float       # Negative = bad, positive = good
    decay_rate: 0.1          # Per hand toward neutral
    
  dramatic_state:
    description: "Narrative tracking for dramatic selection"
    schema:
      tension_level: float   # 0-1
      recent_events: Event[] # Last N significant events
      running_gags: Gag[]    # Active comedic patterns
      unresolved: Tension[]  # Narrative threads
      callbacks_available: Card[]  # Cards that would create callbacks
      
  chaos_level:
    description: "Current chaos intensity"
    schema:
      rules_in_play: int
      recent_rule_changes: int
      goal_changes_this_game: int
      creeper_count: int
      hands_size_variance: float
    thresholds:
      calm: "<3 rules, <2 changes"
      normal: "3-5 rules, 2-4 changes"
      chaotic: "6+ rules, 5+ changes"
      CHAOS_INCARNATE: "10+ rules, goals changing every turn"

# DEALER SELECTION LOGIC

selection_algorithms:

  dramatic_selection:
    steps:
      1_assess_state:
        - "Who is closest to winning?"
        - "What alliances exist?"
        - "What tension is unresolved?"
        - "What would be FUNNY?"
        
      2_score_candidates:
        for_each_available_card:
          drama_score: |
            + proximity_to_victory_impact(card, leader)
            + relationship_test_value(card, alliances)
            + irony_potential(card, current_player)
            + callback_value(card, recent_events)
            + chaos_contribution(card, chaos_level)
            
      3_select:
        method: "weighted random by drama_score"
        # Not deterministic â€” high drama cards MORE LIKELY
        # But not guaranteed â€” maintains some uncertainty
        
      4_document:
        log: "Dealer chose {card} for {player} â€” {reason}"
        narrative_note: "What a coincidence that..."

  karma_selection:
    steps:
      1_calculate_karma:
        - "Sum player's recent actions"
        - "Apply decay toward neutral"
        - "Categorize: saint / good / neutral / bad / villain"
        
      2_weight_by_karma:
        saint: "Helpful cards 3x more likely"
        good: "Helpful cards 1.5x more likely"
        neutral: "No modification"
        bad: "Obstacles 1.5x more likely"
        villain: "Creepers and counters 3x more likely"
        
      3_select:
        method: "weighted random with karma modifiers"
        
      4_narrative:
        good_karma: "The universe smiles on {player}..."
        bad_karma: "Perhaps {player} shouldn't have stolen that card..."

  ironic_selection:
    steps:
      1_identify_needs:
        for_each_player:
          - "What goal could they complete?"
          - "What keeper do they need?"
          - "What would help them most?"
          
      2_find_ironic_matches:
        - "Perfect goal â†’ give to player who CAN'T complete it"
        - "Missing keeper â†’ give to their opponent"
        - "Creeper â†’ give to the leader"
        
      3_select:
        method: "maximize irony score"
        
      4_deliver:
        narration: "Of COURSE that's who drew it..."

# RUNTIME CONFIGURATION

runtime:

  default_mode: "random"
  
  mode_switching:
    allowed: true
    triggers:
      - "Chaos cards"
      - "DM decision"
      - "Chaos level thresholds"
      - "Narrative beats"
      
  blending:
    description: "Modes can be blended for nuance"
    example:
      weights:
        dramatic: 0.6
        karma: 0.3
        random: 0.1
      result: "Mostly dramatic, karma-informed, slight randomness"
      
  transparency:
    to_players: false      # Players don't see dealer reasoning
    to_narrative: true     # Narrative can reference "coincidences"
    to_logs: true          # Full reasoning in game logs
    
  seed:
    description: "For reproducible games"
    usage: "Set seed for explicit_deck mode"
    format: "any string or number"
