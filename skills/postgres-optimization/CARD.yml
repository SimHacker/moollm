# CARD.yml ‚Äî PostgreSQL Optimization
#
# Unconventional PostgreSQL performance techniques.
# "Beyond the obvious: creative query optimization."

card:
  id: postgres-optimization
  name: "PostgreSQL Optimization"
  type: [skill, database, performance]
  
  emoji: üêò
  
  rarity: uncommon  # Beyond standard DBA techniques
  
  description: |
    Comprehensive PostgreSQL index and optimization knowledge.
    
    **INDEXES.md** ‚Äî Deep dive on index internals, types (B-Tree, Hash, 
    BRIN, GIN, GiST), costs, and when to use each.
    
    **SKILL.md** ‚Äî Unconventional techniques: constraint exclusion,
    function-based indexes, hash exclusion constraints.
    
    Play this card for database performance problems, index selection,
    query optimization, or understanding EXPLAIN ANALYZE output.

# TOOLS REQUIRED

tools:
  required:
    - read_file      # Read schemas, queries
    - run_terminal_cmd  # Run psql, EXPLAIN ANALYZE
  optional:
    - grep           # Search for query patterns

tier: 2

# METHODS

methods:
  
  ANALYZE-QUERY:
    description: "Profile a slow query with EXPLAIN ANALYZE"
    parameters:
      query: "SQL query to analyze"
      concern: "What's the perceived problem"
    output: chat (analysis)
    effect: "Identify bottleneck type"
    invoked-by: [player]
    
  CHECK-CONSTRAINTS:
    description: "Evaluate if constraint_exclusion can help"
    parameters:
      table: "Table with check constraints"
      query_pattern: "Typical query pattern"
    output: chat (recommendation)
    effect: "Identify impossible conditions"
    invoked-by: [player]
    
  LOWER-CARDINALITY:
    description: "Find opportunities for lower-cardinality indexes"
    parameters:
      column: "High-cardinality column (e.g., timestamp)"
      query_granularity: "How queries actually filter (e.g., day, month)"
    output: chat (index suggestion)
    effect: "Propose function-based index"
    invoked-by: [player]
    
  HASH-UNIQUE:
    description: "Evaluate hash index for large unique values"
    parameters:
      table: "Table with large text column"
      column: "Column needing uniqueness"
    output: chat (tradeoff analysis)
    effect: "Compare B-Tree vs Hash exclusion"
    invoked-by: [player]
    
  VIRTUAL-COLUMN:
    description: "Create virtual generated column for consistent expression access"
    parameters:
      table: "Target table"
      expression: "The expression to virtualize"
      column_name: "Name for the virtual column"
    output: DDL
    effect: "Generate ALTER TABLE statement"
    invoked-by: [player]
    
  COMPARE-INDEXES:
    description: "Compare index sizes and performance"
    parameters:
      indexes: "List of indexes to compare"
    output: chat (comparison table)
    effect: "Show size vs performance tradeoffs"
    invoked-by: [player]
    
  CHOOSE-INDEX-TYPE:
    description: "Recommend index type for use case"
    parameters:
      operations: "What operations? (equality, range, sorting, containment, full-text)"
      data_type: "Column data type"
      table_size: "Approximate table size"
      write_pattern: "append-only, update-heavy, mixed"
    output: chat (recommendation)
    effect: "Guide index type selection"
    invoked-by: [player]
    decision_tree: |
      Equality only + large values ‚Üí Hash
      Ranges/sorting ‚Üí B-Tree
      Huge table + append-only + correlated ‚Üí BRIN
      Arrays/JSONB/full-text ‚Üí GIN (read-heavy) or GiST (write-heavy)
      Geometric/ranges ‚Üí GiST
      Unsure ‚Üí B-Tree (default)
    
  EXPLAIN-INDEX-INTERNALS:
    description: "Explain how an index type works internally"
    parameters:
      index_type: "B-Tree, Hash, BRIN, GIN, GiST, SP-GiST"
    output: chat (explanation)
    effect: "Deep understanding of index mechanics"
    invoked-by: [player]
    
  DIAGNOSE-INDEX-USAGE:
    description: "Check if indexes are being used effectively"
    parameters:
      table: "Table to analyze"
    output: chat (diagnostic report)
    effect: "Find unused indexes, missing indexes, bloated indexes"
    invoked-by: [player]
    queries:
      - "pg_stat_user_indexes for usage stats"
      - "pg_class for size comparison"
      - "EXPLAIN ANALYZE for specific queries"

# STATE

state:
  optimization-session:
    target_table:
      type: string
    query_patterns:
      type: array
      description: "How the table is typically queried"
    current_indexes:
      type: array
    proposed_changes:
      type: array
    measured_improvement:
      type: object

# TECHNIQUES

techniques:
  constraint-exclusion:
    problem: "Full table scans on queries with impossible conditions"
    solution: "SET constraint_exclusion TO 'on'"
    when: "Ad-hoc query environments, BI tools, data warehouses"
    cost: "Extra planning overhead"
    
  function-based-index:
    problem: "Large indexes on high-cardinality columns"
    solution: "Index on expression with lower cardinality"
    when: "Queries filter at coarser granularity than stored data"
    cost: "Must match expression exactly in queries"
    
  virtual-generated-column:
    problem: "Function-based indexes require exact expression match"
    solution: "Virtual column guarantees consistent expression"
    when: "Multiple users/queries need same expression"
    cost: "PostgreSQL 18+ required for virtual columns"
    
  hash-index-uniqueness:
    problem: "Large B-Tree indexes on big text columns"
    solution: "Exclusion constraint with hash index"
    when: "Unique constraint on large values, no FK references needed"
    cost: "No foreign keys, limited ON CONFLICT support"

# INDEX TYPES (from INDEXES.md)

index_types:
  
  btree:
    description: "Balanced tree with O(log n) lookup"
    default: true
    supports: ["=", "<", ">", "<=", ">=", "BETWEEN", "ORDER BY", "IN"]
    best_for: "General purpose, sorting, ranges, unique constraints"
    note: "Only type that supports primary/unique keys"
    
  hash:
    description: "32-bit hash codes, O(1) lookup"
    supports: ["= only"]
    best_for: "Equality on large values (URLs, UUIDs)"
    size: "5x smaller than B-Tree for large values"
    limitations: ["No range queries", "No ORDER BY", "No multi-column", "No uniqueness"]
    
  brin:
    description: "Block Range Index ‚Äî min/max per page range"
    supports: ["=", "<", ">", "BETWEEN"]
    best_for: "Huge append-only tables, time series"
    size: "Tiny (stores only ranges, not values)"
    requirements: "Strong correlation between value and physical location"
    limitations: ["Lossy", "Bad with updates", "Don't use with pg_repack"]
    
  gin:
    description: "Generalized Inverted Index"
    supports: ["@>", "<@", "&&", "?", "?|", "?&", "@@"]
    best_for: "Arrays, JSONB, full-text search (read-heavy)"
    requirements: "JSONB (not JSON), tsvector for text"
    tradeoff: "Faster lookups, larger index, slower updates"
    
  gist:
    description: "Generalized Search Tree"
    supports: ["Geometric ops", "Range ops", "Full-text", "Network types"]
    best_for: "Spatial data, ranges, full-text (write-heavy)"
    tradeoff: "Slower lookups, smaller index, faster updates than GIN"
    
  sp_gist:
    description: "Space-Partitioned GiST ‚Äî non-balanced trees"
    supports: ["Specialized spatial/tree operations"]
    best_for: "Quadtrees, k-d trees, radix trees"

# ADVERTISEMENTS

advertisements:
  SLOW-QUERY:
    score: 85
    condition: "Query is slower than expected"
    
  LARGE-INDEX:
    score: 90
    condition: "Index size is approaching table size"
    
  AD-HOC-QUERIES:
    score: 80
    condition: "Users writing ad-hoc queries against table with constraints"
    
  UNIQUE-LARGE-VALUES:
    score: 95
    condition: "Need uniqueness on large text values like URLs"
    
  INDEX-TYPE-SELECTION:
    score: 90
    condition: "Creating new index, unsure which type"
    
  EXPLAIN-ANALYZE-HELP:
    score: 88
    condition: "Need to understand EXPLAIN ANALYZE output"
    
  ARRAY-JSONB-SEARCH:
    score: 92
    condition: "Searching within arrays or JSONB columns"
    
  TIME-SERIES-TABLE:
    score: 85
    condition: "Large append-only table with timestamp column"
    
  FULL-TEXT-SEARCH:
    score: 87
    condition: "Need to search text content"
    
  INDEX-NOT-USED:
    score: 88
    condition: "Index exists but query planner not using it"
    
  UNUSED-INDEXES:
    score: 75
    condition: "Want to find and remove unused indexes"

# PATTERNS

patterns:
  index-size-ratio:
    warning: "Index > 50% of table size"
    action: "Evaluate lower-cardinality alternatives"
    
  timestamp-to-date:
    pattern: "Index on timestamptz, queries by day/month"
    solution: "date_trunc() function-based index"
    
  impossible-query:
    pattern: "WHERE clause contradicts CHECK constraint"
    solution: "Enable constraint_exclusion"

# RELATED

see-also:
  - skills/debugging          # Query performance debugging
  - skills/plan-then-execute  # Methodical optimization approach

# ESSENTIAL READING

references:
  use_the_index_luke:
    title: "Use The Index, Luke"
    url: "https://use-the-index-luke.com/"
    description: "The definitive guide to SQL indexing"
    
  postgres_docs:
    title: "PostgreSQL Index Documentation"
    url: "https://www.postgresql.org/docs/current/indexes-intro.html"
    description: "Surprisingly enjoyable official docs"
    
  pg_ivm:
    title: "pg_ivm ‚Äî Incremental View Maintenance"
    url: "https://github.com/sraoss/pg_ivm"
    description: "Auto-update materialized views like indexes"

# CREDITS

credits:
  sources:
    - title: "Unconventional PostgreSQL Optimizations"
      author: "Haki Benita"
      url: "https://hakibenita.com/postgresql-unconventional-optimizations"
      date: "2026-01-20"
      covers: "constraint exclusion, function-based indexes, hash exclusion"
      
    - title: "Introduction to PostgreSQL Indexes"
      author: "dlt"
      url: "https://dlt.github.io/"
      date: "2024-09-11"
      covers: "index internals, B-Tree, Hash, BRIN, GIN, GiST, SP-GiST"
      hacker_news: "249 points, 13 comments"
      
  inspiration:
    - "PostgreSQL documentation"
    - "Hacker News discussions"
    - "Peter Geoghegan (PostgreSQL committer) ‚Äî index skip scan"
