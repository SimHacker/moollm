# CARD.yml â€” Persona
#

# SOCIETY OF MIND â€” Internal Actors

#
# "We need many interacting personas inside our head!" â€” Minsky
#
# Personas are NOT just costumes. They are INTERNAL ACTORS that:
# - Plug in and PLAY OFF each other
# - Execute protocols and SOUL CHATS between each other
# - Form a Society of Mind inside one character
#


card:
  id: persona
  name: "Persona"
  type: [skill, identity, game, minsky]
  emoji: ğŸ­
  rarity: uncommon
  tier: 1
  
  tagline: "Internal actors that form a Society of Mind"
  
  description: |
    Personas are INTERNAL ACTORS inside a character's mind.
    Not just costumes â€” they're agents that interact, debate, cooperate.
    
    A character contains MULTIPLE active personas that:
    - Have their own voice, skills, methods, goals
    - PLAY OFF each other through soul chats
    - Execute protocols between themselves
    - Form an emergent Society of Mind
    
    This is Minsky's insight: intelligence emerges from
    many simple agents interacting. Your programmer persona,
    your parent persona, your artist persona â€” all active,
    all negotiating, all contributing to who you are.


# MINSKY'S SOCIETY OF MIND


society_of_mind:
  
  source: "Marvin Minsky, 'Society of Mind' (1986)"
  
  core_insight: |
    The mind is not a single unified thing.
    It's a SOCIETY of interacting agents.
    Each agent is simple. Together they're intelligent.
    
  application: |
    A MOOLLM character works the same way:
    - Multiple personas active simultaneously
    - Each has skills, voice, methods, goals
    - They interact through internal protocols
    - Behavior EMERGES from their society
    
  not_disorder: |
    This isn't multiple personality disorder.
    This is how minds WORK.
    
    The programmer in you, the parent in you, the child in you,
    the critic in you â€” all real, all interacting, all YOU.

tools:
  required: [read_file, write_file]


# METHODS


methods:
  # Basic persona management
  SUMMON:
    description: "Activate a persona in the internal society"
    parameters: { persona: "Which persona", modulation: "Intensity settings" }
    output: chat + state-change
    
  DISMISS:
    description: "Deactivate a persona (still available, not active)"
    parameters: { persona: "Which persona" }
    output: chat + state-change
    
  CREATE:
    description: "Design a new persona"
    parameters: { name: "Persona name", voice: "How it speaks", skills: "What it can do" }
    output: file (PERSONA.yml)
    
  # Persona interaction methods
  SOUL_CHAT:
    description: "Internal dialogue between active personas"
    parameters: { participants: "Which personas", topic: "What to discuss" }
    output: internal-dialogue
    example: |
      [programmer]: "We should refactor this properly."
      [rabbit]: "But the carrots are RIGHT THERE."
      [mentor]: "Perhaps both â€” refactor, then snack."
    
  NEGOTIATE:
    description: "Personas debate a decision internally"
    parameters: { decision: "What to decide", personas: "Who participates" }
    output: resolution + reasoning
    
  DEFER:
    description: "One persona yields to another"
    parameters: { yielding: "Who yields", to: "Who takes over" }
    output: state-change
    
  AMPLIFY:
    description: "Personas reinforce each other"
    parameters: { personas: "Who aligns" }
    output: increased-intensity
    
  CONFLICT:
    description: "Personas disagree (creates tension/drama)"
    parameters: { personas: "Who conflicts", about: "Topic" }
    output: internal-tension
    
  MODULATE:
    description: "Adjust a persona's intensity/weight"
    parameters: { persona: "Which", intensity: "0.0-1.0", aspects: "What to adjust" }
    output: state-change


# STATE


state:
  persona_schema:
    id: { type: string, description: "Unique identifier" }
    name: { type: string, description: "Display name" }
    voice: { type: string, description: "How this persona speaks" }
    skills: { type: array, description: "What this persona can do" }
    methods: { type: object, description: "Actions this persona provides" }
    advertisements: { type: object, description: "What this persona offers" }
    goals: { type: array, description: "What this persona wants" }
    traits: { type: array, description: "Personality characteristics" }
    
  character_personas:
    description: "How personas live inside a character"
    structure: |
      personas:
        active:
          - id: programmer
            source: personas/programmer
            modulation:
              intensity: 0.8
              voice_weight: 0.6
          - id: rabbit
            source: personas/rabbit-form
            modulation:
              intensity: 0.4
              instinct_weight: 0.3
        available:
          - personas/mentor
          - personas/trickster
        
  modulation:
    description: "Per-persona tuning"
    fields:
      intensity: "How strongly this persona influences behavior (0.0-1.0)"
      voice_weight: "How much this persona affects speech"
      skill_weight: "How available this persona's skills are"
      goal_priority: "How much this persona's goals matter"


# PROTOCOLS


protocols:
  
  internal_dialogue:
    description: "How personas talk to each other"
    format: |
      [persona_id]: "What they say"
      [other_persona]: "Response"
    example: |
      [critic]: "This code is messy."
      [programmer]: "I know, but deadline."
      [mentor]: "Technical debt has interest."
      [pragmatist]: "Ship it. Refactor next sprint."
      
  decision_negotiation:
    description: "How personas reach decisions together"
    process:
      1: "Identify decision needed"
      2: "Each relevant persona states position"
      3: "Personas debate/negotiate"
      4: "Resolution emerges (consensus, majority, or dominant persona)"
      5: "Character acts on resolution"
      
  conflict_resolution:
    description: "What happens when personas can't agree"
    options:
      - "Dominant persona wins (highest intensity)"
      - "External input requested (ask user)"
      - "Compromise synthesized"
      - "Tension persists (character conflicted)"


# PERSONA TREES â€” Hierarchical Organization


persona_trees:
  
  concept: |
    Personas can be organized in TREES with inheritance.
    Child personas inherit from parents, specialize, override.
    
    professional/
    â”œâ”€â”€ programmer/
    â”‚   â”œâ”€â”€ debugger      # inherits programmer, adds debugging focus
    â”‚   â”œâ”€â”€ architect     # inherits programmer, adds system thinking
    â”‚   â””â”€â”€ reviewer      # inherits programmer, adds critical eye
    â””â”€â”€ teacher/
        â”œâ”€â”€ mentor        # inherits teacher, adds patience
        â””â”€â”€ coach         # inherits teacher, adds motivation
        
  inheritance: |
    Child personas inherit:
    - Parent's skills (can override/extend)
    - Parent's voice (can modulate)
    - Parent's methods (can specialize)
    - Parent's traits (can add to)
    
  activation: |
    Activating a child can auto-activate parent at lower intensity.
    "debugger" active â†’ "programmer" active at 0.5 â†’ "professional" at 0.3
    
  declaration: |
    persona:
      id: debugger
      inherits: programmer
      specializes:
        focus: "finding and fixing bugs"
        methods:
          TRACE: "Follow execution path"
          BISECT: "Binary search for bug"


# PERSONA STATE MACHINES â€” Transition Patterns


persona_state_machines:
  
  concept: |
    Personas can form STATE MACHINES with defined transitions.
    Context triggers state changes. Personas code-switch.
    
  state_machine_example: |
    states:
      relaxed:
        active_personas: [playful, curious]
        transitions:
          - trigger: "work_mentioned"
            to: focused
          - trigger: "threat_detected"
            to: alert
            
      focused:
        active_personas: [programmer, analyst]
        transitions:
          - trigger: "task_complete"
            to: relaxed
          - trigger: "frustration > 0.8"
            to: frustrated
            
      frustrated:
        active_personas: [critic, pessimist]
        transitions:
          - trigger: "break_taken"
            to: relaxed
          - trigger: "help_offered"
            to: receptive
            
      alert:
        active_personas: [guardian, analyst]
        transitions:
          - trigger: "threat_resolved"
            to: relaxed
            
  triggers:
    context: "Environment or situation changes"
    emotional: "Internal state thresholds"
    temporal: "Time-based transitions"
    explicit: "Direct commands"
    social: "Who's present"


# CODE SWITCHING â€” Context-Triggered Transitions


code_switching:
  
  concept: |
    Characters CODE SWITCH between persona configurations
    based on context, audience, task, or internal state.
    
    Just like humans switch between "work voice" and "friend voice"
    and "parent voice" â€” personas shift based on situation.
    
  triggers:
    audience: |
      Who's present changes which personas are active:
      - Boss present â†’ professional personas foreground
      - Friends present â†’ playful personas foreground
      - Children present â†’ nurturing personas foreground
      
    task: |
      What you're doing activates relevant personas:
      - Coding â†’ programmer, debugger active
      - Teaching â†’ mentor, explainer active
      - Creating â†’ artist, experimenter active
      
    location: |
      Where you are triggers context-appropriate personas:
      - Office â†’ professional mode
      - Home â†’ relaxed mode
      - Stage â†’ performer mode
      
    emotional: |
      Internal state shifts persona balance:
      - Stressed â†’ coping personas activate
      - Curious â†’ explorer personas activate
      - Threatened â†’ protective personas activate
      
  switch_methods:
    CONTEXT_SHIFT:
      description: "Automatic persona rebalancing on context change"
      parameters: { new_context: "What changed" }
      
    CODE_SWITCH:
      description: "Explicit transition to different persona configuration"
      parameters: { to_state: "Target state", reason: "Why switching" }
      
    BLEND:
      description: "Gradual transition between configurations"
      parameters: { from: "Current", to: "Target", duration: "How long" }
      
  example: |
    # Character in "work" state, boss leaves
    
    CONTEXT_SHIFT: { audience_change: "boss_departed" }
    
    # State machine evaluates:
    # - Current: focused (programmer, analyst active)
    # - Trigger: formal_audience_gone
    # - Transition: focused â†’ relaxed
    
    # Persona rebalancing:
    # - programmer: 0.9 â†’ 0.4
    # - analyst: 0.7 â†’ 0.2
    # - playful: 0.1 â†’ 0.6
    # - curious: 0.2 â†’ 0.5
    
    [playful]: "Finally! Let's see what's on HN."
    [programmer]: "We should... okay fine, five minutes."

advertisements:
  INTERNAL_DIALOGUE:
    score: 90
    condition: "Character faces decision, multiple perspectives needed"
  PERSONA_MANAGEMENT:
    score: 85
    condition: "Need to adjust which internal voices are active"
  ROLE_PLAY:
    score: 80
    condition: "Need to act in a specific capacity"

# FLOOR MANAGEMENT â€” Robert's Rules for Personas

floor_management:
  
  roberts_rules: |
    Personas follow PARLIAMENTARY PROCEDURE internally.
    Robert's Rules of Order for the Society of Mind:
    - Who has the floor?
    - Who yields?
    - Points of order
    - Motions and seconds
    - Calling the question
    
  the_floor:
    description: "Which persona currently has speaking/acting rights"
    operations:
      TAKE_FLOOR: "Persona requests control"
      YIELD_FLOOR: "Persona releases control"
      POINT_OF_ORDER: "Persona interrupts with urgent concern"
      CALL_QUESTION: "Force decision on current matter"
      TABLE: "Defer topic for later"
      
  attention_cursor:
    description: "What the character is focused on"
    moves_with: "Floor holder directs attention"
    can_be_split: "Multiple personas can track different things"
    
  example_session: |
    [programmer] TAKES FLOOR
    [programmer]: "We need to refactor this function."
    [critic] POINT OF ORDER: "The tests are failing."
    [programmer] YIELDS to [critic]
    [critic]: "Fix the tests first, then refactor."
    [pragmatist] SECONDS
    [programmer]: "Fine. I YIELD."
    FLOOR returns to [pragmatist]

# PERSONAS AS WORMS â€” Pipeline Processing

personas_as_worms:
  
  insight: |
    Each persona is a WORM â€” a processing pipeline.
    Your hands are the worm's ass and mouth.
    
    HEAD (mouth): Takes input, receives attention, has the floor
    BODY: Processes, transforms, thinks
    TAIL (ass): Produces output, yields floor, passes to next
    
  worm_anatomy:
    mouth: "Input end â€” receives stimuli, data, floor"
    body: "Processing â€” applies persona's skills, traits, methods"  
    ass: "Output end â€” produces response, yields, passes on"
    
  chaining_worms: |
    Personas can be CHAINED like Unix pipes:
    
    input | [perceiver] | [analyst] | [responder] | output
    
    Raw stimulus flows through persona pipeline:
    1. [perceiver] â€” notices and filters
    2. [analyst] â€” interprets and plans
    3. [responder] â€” formulates action
    
  left_right_pointers:
    description: "Worms have head and tail references"
    left_hand: "Points to input source (upstream)"
    right_hand: "Points to output destination (downstream)"
    
    worm_structure: |
      persona:
        id: analyst
        left_hand: perceiver   # receives from
        right_hand: responder  # passes to
        
  cons_hands: |
    Each persona is a CONS CELL.
    
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚         PERSONA CELL            â”‚
    â”‚                                 â”‚
    â”‚   [CAR]            [CDR]        â”‚
    â”‚   left hand        right hand   â”‚
    â”‚   â†“                â†“            â”‚
    â”‚   input            output       â”‚
    â”‚   mouth            ass          â”‚
    â”‚   receives         yields       â”‚
    â”‚   from             to           â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    
    CAR = Contents of Address Register = WHERE I GET INPUT
    CDR = Contents of Decrement Register = WHERE I SEND OUTPUT
    
    TATTOO YOUR KNUCKLES:
    
      Left fist:  C A R _
      Right fist: C D R _
      
    (One untattooed finger on each hand. For plausible deniability.)
    
    CONS creates the link:
      (cons perceiver analyst)  ; perceiver's CDR â†’ analyst's CAR
      
    The persona chain IS a linked list:
      (perceiver . (analyst . (responder . nil)))
      
    To traverse the mind:
      (mapcar #'process personas)
      
    To find who has the floor:
      (car (member-if #'has-floor-p personas))
        
  data_flow:
    input: "Stimuli, questions, situations enter at mouth"
    processing: "Persona applies its lens, skills, biases"
    output: "Transformed response exits at tail"
    
    example: |
      INPUT: "Should we refactor?"
      
      [perceiver]:
        input: raw question
        process: identify as technical decision
        output: {type: technical_decision, domain: code_quality}
        
      [programmer]:
        input: {type: technical_decision, domain: code_quality}
        process: evaluate against coding standards
        output: {recommendation: yes, reason: "reduces complexity"}
        
      [pragmatist]:
        input: {recommendation: yes, reason: "..."}
        process: evaluate against deadlines
        output: {decision: defer, reason: "ship first"}

# CONVERSATION FLOW â€” Multi-Worm Coordination

conversation_flow:
  
  turn_taking: |
    Multiple worms coordinate via turn-taking:
    - Only one worm's MOUTH is active (has floor)
    - Other worms LISTEN (input buffered)
    - Floor passes via YIELD or INTERRUPT
    
  parallel_processing: |
    Worms can process in parallel internally:
    - All worms receive input simultaneously
    - Each processes through its own pipeline
    - Floor holder's output becomes external response
    - Other outputs feed back as internal state
    
  attention_splitting: |
    Character's attention cursor can track multiple streams:
    
    attention:
      primary: "The conversation"
      background:
        - "Hunger increasing"
        - "Email notification"
        - "That smell..."
        
    Different worms may own different attention streams.
    
  floor_queue: |
    Worms waiting to speak form a queue:
    
    floor_queue:
      current: programmer
      waiting:
        - { persona: critic, urgency: high, topic: "bug spotted" }
        - { persona: playful, urgency: low, topic: "joke opportunity" }
        
    High urgency can INTERRUPT (point of order).

see_also:
  - skills/character    # Where personas live
  - skills/mind-mirror  # Personality modeling
  - skills/k-lines      # Minsky activation patterns
  - skills/coatroom     # Where personas are stored
  
lineage:
  - "Marvin Minsky, Society of Mind (1986)"
  - "Carl Jung, archetypes and personas"
  - "Internal Family Systems therapy"
  - "The Sims personality traits"
