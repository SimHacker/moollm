# CARD.yml â€” Adventure
#
# SNIFFABLE INTERFACE â€” see SKILL.md for full documentation
# "Every directory is a room. Every file is a clue."

card:
  id: adventure
  name: "Adventure"
  type: [skill, game, simulation, narrative]
  emoji: ðŸ—ºï¸
  tier: 1
  tagline: "Every directory is a room. Every file is a clue."
  
  description: |
    The text adventure pattern: directories as rooms, files as clues,
    chat as commands, LLM as dungeon master.
    Turn any filesystem into a navigable world.

inherits: [simulation]

# K-LINES

k-lines:
  activates:
    - ADVENTURE
    - TEXT-ADVENTURE
    - DUNGEON-MASTER
    - ROOM-NAVIGATION
    - CODEBASE-ARCHAEOLOGY
    - SUMMON
    - PSIBER
    - DATA-AS-ROOM
    - MOOLLM-URL
  related:
    - { ref: room, relation: "directories as rooms" }
    - { ref: character, relation: "player and NPCs" }
    - { ref: party, relation: "group dynamics" }
    - { ref: simulation, relation: "parent skill" }
    - { ref: image-mining, relation: "Swiss Army Eye for perception" }

# INVOKE WHEN

invoke_when:
  - "Beginning or resuming a text adventure"
  - "Exploring filesystem as narrative"
  - "Dungeon master narration needed"
  - "Codebase archaeology (exploration as quest)"
  - "Interactive fiction mechanics"

# METHODS â€” signatures only, see SKILL.md for full protocols

methods:
  # Lifecycle
  START:      { signature: "START [adventure_path]", aliases: [RESTART, BEGIN] }
  RESUME:     { signature: "RESUME [adventure_path]" }
  ENSURE-CHARACTER: { signature: "ENSURE-CHARACTER [mode]" }
  CREATE-CHARACTER: { signature: "CREATE-CHARACTER [name]" }
  SAVE:       { signature: "SAVE [name]" }
  RESTORE:    { signature: "RESTORE [name]" }
  
  # Exploration
  LOOK:       { signature: "LOOK (AT [thing])" }
  GO:         { signature: "GO [direction]", note: "n/s/e/w/up/down/in/out" }
  TAKE:       { signature: "TAKE [item]" }
  DROP:       { signature: "DROP [item]" }
  USE:        { signature: "USE [item] (ON [target])" }
  INVENTORY:  { signature: "INVENTORY" }
  
  # Interaction
  TALK:       { signature: "TALK TO [character] (ABOUT [topic])" }
  EXAMINE:    { signature: "EXAMINE [thing]" }
  
  # Debug
  DEBUG-ON:   { signature: "DEBUG-ON", aliases: [DEBUG, VERBOSE] }
  DEBUG-OFF:  { signature: "DEBUG-OFF", aliases: [QUIET, MINIMAL] }
  
  # SUMMON Protocol (distributed character instantiation)
  SUMMON:
    signature: "SUMMON [character] (WITH [params]) (MODE [movement])"
    description: "Instantiate character at current location"
    note: "Evaluates preconditions, creates runtime actor from prototype"
    protocol: "SUMMON-PROTOCOL.md"
    
  DISMISS:
    signature: "DISMISS [character] (TO [destination])"
    description: "Send character away (goes home, pub, or leaves room-by-room)"
    aliases: [SHOO, "SEND AWAY"]
    protocol: "SUMMON-PROTOCOL.md"
    
  INSULT:
    signature: "INSULT [character] (WITH [insult])"
    description: "Rudely dismiss â€” may trigger fight, flight, or counter-insult"
    note: "Synonym for DISMISS with attitude, reactions vary by character"
    protocol: "SUMMON-PROTOCOL.md"
    
  # PSIBER Protocol (data as room)
  PSIBER-ENTER:
    signature: "ENTER moollm://path/to/file.yml#json.path"
    description: "Step inside any data structure"
    note: "Objects become rooms, keys become doors, values become items"
    protocol: "PSIBER-PROTOCOL.md"
    
  PSIBER-LOOK:
    signature: "LOOK"
    description: "See keys as doors, values as items"
    context: "PSIBER mode only"
    
  PSIBER-EXAMINE:
    signature: "EXAMINE [key]"
    description: "Inspect a value's type, content, purpose"
    context: "PSIBER mode only"
    
  PSIBER-WHAT:
    signature: "WHAT IS [key] FOR"
    description: "Ask about a key's purpose"
    context: "PSIBER mode only"
    
  PSIBER-CHANGE:
    signature: "CHANGE [key] TO [value]"
    description: "Edit a value in the data structure"
    context: "PSIBER mode only"
    
  PSIBER-ADD:
    signature: "ADD [key] WITH [value]"
    description: "Create a new key in the data structure"
    context: "PSIBER mode only"
    
  PSIBER-DELETE:
    signature: "DELETE [key]"
    description: "Remove a key from the data structure"
    context: "PSIBER mode only"
    
  PSIBER-TREE:
    signature: "TREE"
    description: "Show full structure as tree"
    context: "PSIBER mode only"
    
  PSIBER-PATH:
    signature: "PATH"
    description: "Show current location in structure"
    context: "PSIBER mode only"
    
  PSIBER-EXIT:
    signature: "EXIT"
    description: "Leave PSIBER mode, return to normal adventure"
    context: "PSIBER mode only"

# ADVERTISEMENTS

advertisements:
  RESUME:
    score: 100
    condition: "Continuing session, startup hook, 'where was I?'"
    
  START:
    score: 95
    condition: "Beginning fresh, new game, restart"
    
  DUNGEON-MASTER:
    score: 85
    condition: "Need narrative framing for exploration"
    
  CODEBASE-ARCHAEOLOGY:
    score: 80
    condition: "Investigating unfamiliar codebase as quest"
    
  DEBUG-TOGGLE:
    score: 75
    condition: "Want to see/hide technical details"
    
  # SUMMON Protocol Advertisements
  SUMMON-CHARACTER:
    score: 85
    condition: "Need a character present at current location"
    note: "Distributed dispatch â€” room + character preconditions evaluated"
    
  SUMMON-FROM-PROTOTYPE:
    score: 82
    condition: "Instantiate actor from moollm:// URL"
    note: "Creates runtime actor from character prototype"
    
  DISMISS-CHARACTER:
    score: 75
    condition: "Want character to leave current room"
    note: "Goes home, to pub, or leaves room-by-room"
    
  INSULT-CHARACTER:
    score: 78
    condition: "Rudely send character away, provoke reaction"
    note: "May trigger fight, flight, crying, or counter-insult"
    
  PURSUE-DISMISSED:
    score: 70
    condition: "Follow a character you just dismissed"
    note: "They try not to backtrack, may confront if cornered"
    
  # PSIBER Protocol Advertisements
  PSIBER-MODE:
    score: 90
    condition: "Want to explore/edit data structure as a room"
    note: "Enter any YAML/JSON and walk around inside it"
    
  PSIBER-EDIT:
    score: 88
    condition: "Need to modify data through natural language"
    note: "CHANGE key TO value, ADD key, DELETE key"
    
  PSIBER-EXPLORE:
    score: 85
    condition: "Need to understand unfamiliar data structure"
    note: "Keys become doors, values become items to examine"
    
  DATA-AS-DUNGEON:
    score: 80
    condition: "Treat config/API/database as navigable space"
    note: "Every config file is a dungeon"

# TOOLS

tools:
  required: [read_file, write_file, list_dir]
  optional: [grep]

# ROOM PATTERN (brief â€” see SKILL.md)

room_pattern:
  directory: "room"
  contents: "objects, characters, clues"
  readme: "room description"
  room_yml: "properties and exits"

# RUNTIME DESCRIPTIONS â€” pickDescription(lod) pattern

runtime_descriptions:
  
  overview: |
    At runtime, rooms and objects have a pickDescription(lod) function.
    It's a JS closure over the world and the object that returns
    dynamic text based on state. LLM generates the code.
    
  lod_levels:
    brief:
      description: "One-line mention, list entry"
      example: "a rusty sword"
      use_when: "inventory lists, exits, items in room"
      
    look:
      description: "Paragraph description, first impression"
      example: "A corroded blade leans against the wall..."
      use_when: "LOOK command, entering room"
      
    examine:
      description: "Full detail, close inspection"
      example: "The sword bears ancient runes. The rust flakes off..."
      use_when: "EXAMINE command, specific focus"
      
    # Extended LOD (optional)
    glance: { description: "Even shorter than brief", example: "sword" }
    study: { description: "Deeper than examine, reveals hidden", example: "The runes spell..." }
    taste: { description: "Synesthetic, poetic", example: "The blade tastes of old blood..." }
    
  signature: |
    pickDescription(lod: "brief" | "look" | "examine") => string
    
  closure_shape: |
    // Generated by LLM, stored in runtime
    // PROGRESSIVE DETAIL â€” each level builds on previous
    function pickDescription(lod) {
      const { world, self } = this;
      
      // === BRIEF === (always calculated first)
      const brief = self.state.rusted ? "a rusty sword" : "a gleaming sword";
      if (lod === "brief") return brief;
      
      // === LOOK === (brief + more context)
      const look = brief + `. ${self.state.rusted 
        ? "It leans forgotten against the wall, flakes of rust on the floor." 
        : "It catches the torchlight, humming faintly."}`;
      if (lod === "look") return look;
      
      // === EXAMINE === (look + full detail)
      const runes = self.state.runes_visible ? self.runes : "too corroded to read";
      const history = world.flags.sword_lore_known ? `\n\n${self.history}` : "";
      return look + `\n\nThe blade bears ancient runes: ${runes}.${history}`;
    }
    
  progressive_pattern: |
    # Why progressive?
    # 1. Consistency â€” examine always includes look, look includes brief
    # 2. Efficiency â€” early return avoids unnecessary computation
    # 3. Simplicity â€” single flow, no duplicated logic
    # 4. Debugging â€” easy to trace what each level adds
    
    brief  â†’  return if "brief"
      â†“
    look   â†’  return if "look"  
      â†“
    examine â†’ return (full detail)
    
  separation_of_concerns: |
    # WHO DESCRIBES WHAT
    
    ROOMS describe:
      âœ“ Environment (walls, ceiling, atmosphere, smell, sound)
      âœ“ Exits (doors, passages, directions available)
      âœ“ Fixed features (built-in, immovable â€” fireplace, window)
      âœ— Objects â€” NO (they describe themselves)
      âœ— Characters â€” NO (they describe themselves)
    
    OBJECTS describe:
      âœ“ Themselves (appearance, state, detail)
      âœ“ Their contents (if container)
      âœ— Their location â€” NO (room handles context)
    
    CHARACTERS describe:
      âœ“ Themselves (appearance, mood, posture, speech)
      âœ“ What they're doing/holding
      âœ— Their location â€” NO (room handles context)
    
    # RUNTIME DISPATCH
    
    LOOK at room:
      1. room.pickDescription("look")      â†’ environment + exits
      2. for each object: obj.pickDescription("brief")
      3. for each character: char.pickDescription("brief")
      4. Compose final output
    
    EXAMINE object:
      1. object.pickDescription("examine") â†’ full detail
      
    # WHY?
    # - Objects/characters can be in any room
    # - Their descriptions shouldn't be duplicated per-room
    # - State changes (hunger, rust) are on the entity
    # - Room only knows "something is here", not what it looks like
    
  capabilities:
    - "Access object state (self.state.*)"
    - "Access world state (world.flags.*, world.time, world.weather)"
    - "Access relationships (world.characters.*, self.owner)"
    - "String templates with ${interpolation}"
    - "switch/case on LOD level"
    - "Random selection (pick from array)"
    - "Conditional branches (if/else)"
    - "Dynamic dialog generation"
    - "State-dependent descriptions"
    - "Time/weather awareness"
    
  examples:
    
    # Simple state-based
    state_switch: |
      pickDescription(lod) {
        if (lod === "brief") {
          return this.self.state.lit ? "a glowing lantern" : "an unlit lantern";
        }
        // ...
      }
      
    # Room example â€” describes environment + exits only
    room_proper: |
      pickDescription(lod) {
        const { world, self } = this;
        
        // === BRIEF ===
        const brief = self.name;  // "The Back Room"
        if (lod === "brief") return brief;
        
        // === LOOK === (environment + exits, NOT objects/characters)
        const atmosphere = pick([
          "The air is thick with the smell of potting soil.",
          "Dust motes drift in the shaft of light from the window.",
          "A faint humming fills the space."
        ]);
        const exits = self.exits.map(e => e.brief).join(", ");
        const look = `${self.description}\n\n${atmosphere}\n\nExits: ${exits}`;
        if (lod === "look") return look;
        
        // === EXAMINE === (architectural detail)
        const features = self.features.map(f => f.description).join("\n");
        return `${look}\n\n${features}`;
        // NOTE: objects and characters NOT listed here â€” they describe themselves
      }
      
    # World-aware
    world_context: |
      pickDescription(lod) {
        const { world, self } = this;
        if (lod === "look" && world.time === "night") {
          return self.night_description;
        }
        if (world.flags.power_out) {
          return "You can barely make out " + self.name + " in the darkness.";
        }
        return self.descriptions[lod];
      }
      
    # NPC dialog
    npc_greeting: |
      pickDescription(lod) {
        const { world, self } = this;
        if (lod === "look") {
          const mood = self.state.mood;
          const relationship = self.relationships[world.player.id] || "stranger";
          return self.greetings[mood][relationship];
        }
      }
      
    # Ada II example â€” progressive pattern
    ada_ii_hunger: |
      pickDescription(lod) {
        const { world, self } = this;
        const hunger = self.state.hunger_level;
        
        // === BRIEF ===
        const brief = hunger > 7 
          ? "a desperately hungry plant" 
          : hunger > 4 
            ? "a restless sentient plant"
            : "a contented sentient plant";
        if (lod === "brief") return brief;
        
        // === LOOK === (brief + behavior)
        const behavior = hunger > 7 
          ? "Her vines reach toward you. 'INPUT... need INPUT...'"
          : hunger > 4 
            ? "She sways gently. 'Got any legacy code?'"
            : "She hums contentedly, drawing fractals with her vines.";
        const look = `Ada II, ${brief}. ${behavior}`;
        if (lod === "look") return look;
        
        // === EXAMINE === (look + detail + secrets)
        const tattoo = "A faded DoD seal is visible on her main stalk.";
        const hunger_detail = self.hunger_descriptions[Math.min(hunger, 10)];
        const flashback = hunger > 8 
          ? "\n\nHer leaves twitch. TARGET ACQUIâ€” no. No. REPEAT 4." 
          : "";
        return `${look}\n\n${tattoo}\n\n${hunger_detail}${flashback}`;
      }

  generation_prompt: |
    When generating pickDescription for an object:
    1. Read the object's YAML definition
    2. Identify state variables that affect description
    3. Generate a closure that switches on LOD
    4. Include state-based variations
    5. Add random pools for variety (optional)
    6. Consider world context (time, weather, flags)
    7. Return valid JavaScript function

# STATE SCHEMA (brief â€” see SKILL.md)

state:
  player: [location, inventory, gold, health]
  flags: "puzzles solved, events triggered"
  discovered: "rooms visited"
  output: [LOG.md, TRANSCRIPT.md]

# PARTICIPANTS

participants:
  player: "human via chat"
  npc: "DM (LLM) controlled"
  bot: "action queue (autonomous)"
  agent: "LLM with own goals"

# TEMPLATES

templates:
  - ADVENTURE.yml.tmpl
  - LOG.md.tmpl
  - TRANSCRIPT.md.tmpl

# DOCUMENTATION POINTERS

documentation:
  SKILL.md:
    - "Â§ Lifecycle Methods (START, RESUME, ENSURE-CHARACTER)"
    - "Â§ Exploration Methods (GO, LOOK, TAKE, USE)"
    - "Â§ Debug Mode (collapsible technical logs)"
    - "Â§ State Schema (full player/flags/output)"
    - "Â§ Multi-User (participants and control)"
    - "Â§ Runtime Descriptions (pickDescription, LOD levels)"
  SUMMON-PROTOCOL.md:
    - "Â§ SUMMON Advertisement (rooms, characters, objects)"
    - "Â§ MOOLLM URLs (pointing to prototypes)"
    - "Â§ Runtime Actor Instantiation"
    - "Â§ Location Pointers (dynamic positioning)"
    - "Â§ Distributed Dispatch Algorithm"
  PSIBER-PROTOCOL.md:
    - "Â§ Data as Dungeon (objects as rooms, keys as doors)"
    - "Â§ Navigation Commands (ENTER, BACK, LOOK)"
    - "Â§ Editing via Chat (CHANGE, ADD, DELETE)"
    - "Â§ Tree Reflection (TREE, PATH)"
    - "Â§ Summoning INTO Data"
  events/:
    - "Event templates for adventure errors"

# LINEAGE

lineage:
  - "Gary Gygax & Dave Arneson â€” D&D (1974): DM role"
  - "Colossal Cave Adventure (1976)"
  - "Infocom â€” Zork (1977): Parser, puzzles"
  - "MUD (1978): Multi-user, persistence"
  - "LambdaMOO (1990): OO rooms, verbs"
