/**
 * export-compiler.js â€” Runtime loader for MOOLLM adventure exports
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * 
 * LOADING MODES:
 * 
 *   1. EMBEDDED (Production)
 *      - LLM compiled everything into adventure-data.js
 *      - const adventureData = { rooms: [...], ... };
 *      - Fast, works offline, static hosting
 *      
 *   2. INJECTED (Build step)
 *      - <script src="adventure-data.json"></script>
 *      - Or: fetch('adventure-data.json')
 *      - Generated by CI/build process
 *      
 *   3. LIVE FROM GITHUB (Dev/Debug)
 *      - Fetch YAML from raw.githubusercontent.com
 *      - Specify branch/tag/commit: ?ref=feature-branch
 *      - Reload without rebuild â€” see changes live!
 *      - Useful for testing, debugging, exploring
 *      
 *   4. HYBRID
 *      - Embed core data, lazy-load extras from GitHub
 *      - Fast initial load, dynamic expansion
 * 
 * THE LLM IS THE COMPILER:
 *   - Reads export manifest YAML
 *   - Fetches all sources  
 *   - Processes dialog layers
 *   - Generates static bundle
 *   - This file just LOADS what was compiled
 * 
 * HERITAGE: Myst (1993) + The Sims (2000)
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 */

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// EXPORT MANIFEST â€” What to include
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Default export manifest structure
 */
const DEFAULT_MANIFEST = {
    id: 'unnamed-export',
    name: 'Unnamed Export',
    version: '1.0.0',
    
    include: {
        rooms: [],
        objects: [],
        characters: [],
        prototypes: [],
        slideshows: []   // Photo archives with generated images
    },
    
    entry: {
        room: 'lobby',
        initial_view: 'overview'
    },
    
    views: {
        overview: true,
        exploration: true,
        catalog: true,
        album: false,
        prototypes: true
    },
    
    features: {
        pie_menus: true,
        drag_drop: true,
        inventory: true,
        speech_synthesis: true,
        source_viewer: true
    },
    
    monetization: {
        type: 'none'
    }
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// EXPORT COMPILER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class ExportCompiler {
    constructor(options = {}) {
        this.manifest = null;
        this.collected = {
            rooms: new Map(),
            objects: new Map(),
            characters: new Map(),
            prototypes: new Map(),
            slideshows: new Map()
        };
        
        // Loading mode
        this.mode = options.mode || 'github';  // 'embedded', 'injected', 'github', 'hybrid'
        
        // GitHub settings for live loading
        this.org = options.org || 'leela-ai';
        this.repo = options.repo || 'moollm';
        this.ref = options.ref || 'main';  // branch, tag, or commit SHA
        
        // Base URL for raw file access
        // Can override with options.baseUrl or construct from org/repo/ref
        this.baseUrl = options.baseUrl || 
            `https://raw.githubusercontent.com/${this.org}/${this.repo}/${this.ref}`;
        
        // Pre-compiled data (if mode is 'embedded' or 'hybrid')
        this.embeddedData = options.embeddedData || null;
    }
    
    /**
     * Load from embedded/injected data (fast, offline)
     */
    loadFromEmbedded(data) {
        this.mode = 'embedded';
        this.embeddedData = data;
        
        // Populate collected maps from embedded data
        (data.rooms || []).forEach(r => this.collected.rooms.set(r.id, r));
        (data.objects || []).forEach(o => this.collected.objects.set(o.id, o));
        (data.characters || []).forEach(c => this.collected.characters.set(c.id, c));
        (data.archetypes || []).forEach(p => this.collected.prototypes.set(p.id, p));
        (data.slideshows || []).forEach(s => this.collected.slideshows.set(s.id, s));
        
        this.manifest = data._manifest || { name: data.name };
        
        console.log(`ğŸ“¦ Loaded embedded: ${data.name}`);
        return this.collected;
    }
    
    /**
     * Switch to a different branch/tag/commit
     */
    setRef(ref) {
        this.ref = ref;
        this.baseUrl = `https://raw.githubusercontent.com/${this.org}/${this.repo}/${this.ref}`;
        console.log(`ğŸ”€ Switched to ref: ${ref}`);
        return this;
    }
    
    /**
     * Load and validate an export manifest
     */
    async loadManifest(manifestPath) {
        const response = await fetch(manifestPath);
        const text = await response.text();
        
        // Parse YAML
        const manifest = typeof YAML !== 'undefined' 
            ? YAML.parse(text) 
            : JSON.parse(text);
        
        // Merge with defaults
        this.manifest = this._mergeDefaults(manifest);
        
        return this.manifest;
    }
    
    /**
     * Merge manifest with defaults
     */
    _mergeDefaults(manifest) {
        return {
            ...DEFAULT_MANIFEST,
            ...manifest,
            include: {
                ...DEFAULT_MANIFEST.include,
                ...manifest.include
            },
            entry: {
                ...DEFAULT_MANIFEST.entry,
                ...manifest.entry
            },
            views: {
                ...DEFAULT_MANIFEST.views,
                ...manifest.views
            },
            features: {
                ...DEFAULT_MANIFEST.features,
                ...manifest.features
            }
        };
    }
    
    /**
     * Collect all resources specified in manifest
     */
    async collect() {
        if (!this.manifest) {
            throw new Error('Load manifest first');
        }
        
        console.log(`ğŸ“¦ Collecting resources for: ${this.manifest.name}`);
        console.log(`   Source: ${this.org}/${this.repo}@${this.ref}`);
        
        // Collect rooms
        for (const roomSpec of this.manifest.include.rooms || []) {
            await this._collectRooms(roomSpec);
        }
        
        // Collect prototypes (archetypes)
        for (const protoSpec of this.manifest.include.prototypes || []) {
            await this._collectPrototypes(protoSpec);
        }
        
        // Collect objects
        for (const objSpec of this.manifest.include.objects || []) {
            await this._collectObject(objSpec);
        }
        
        // Collect characters
        for (const charSpec of this.manifest.include.characters || []) {
            await this._collectCharacter(charSpec);
        }
        
        // Collect slideshows
        for (const slideSpec of this.manifest.include.slideshows || []) {
            await this._collectSlideshow(slideSpec);
        }
        
        console.log(`âœ… Collected: ${this.collected.rooms.size} rooms, ` +
                    `${this.collected.prototypes.size} prototypes, ` +
                    `${this.collected.objects.size} objects, ` +
                    `${this.collected.characters.size} characters, ` +
                    `${this.collected.slideshows.size} slideshows`);
        
        return this.collected;
    }
    
    /**
     * Collect rooms from a spec
     */
    async _collectRooms(spec) {
        const path = typeof spec === 'string' ? spec : spec.path;
        const recursive = spec.recursive !== false;
        
        // Handle glob patterns
        if (path.includes('*')) {
            // Would need glob expansion here
            console.log(`  ğŸ“ Room glob: ${path}`);
            return;
        }
        
        // Fetch room YAML
        try {
            const roomYaml = await this._fetchFile(`${path}/ROOM.yml`);
            if (roomYaml) {
                const room = typeof YAML !== 'undefined' 
                    ? YAML.parse(roomYaml) 
                    : JSON.parse(roomYaml);
                room.source_path = path;
                this.collected.rooms.set(room.id || path, room);
                console.log(`  ğŸšª Room: ${room.name || room.id}`);
            }
        } catch (e) {
            console.warn(`  âš ï¸ Could not load room: ${path}`);
        }
    }
    
    /**
     * Collect prototypes (archetypes)
     */
    async _collectPrototypes(spec) {
        const path = typeof spec === 'string' ? spec : spec.path;
        
        // Handle glob patterns like "archetypes/*.yml"
        if (path.includes('*')) {
            console.log(`  ğŸ¤– Prototype glob: ${path} (would expand)`);
            // In real impl, would list directory and fetch each
            return;
        }
        
        // Single prototype
        try {
            const protoYaml = await this._fetchFile(path);
            if (protoYaml) {
                const proto = typeof YAML !== 'undefined'
                    ? YAML.parse(protoYaml)
                    : JSON.parse(protoYaml);
                proto.source_path = path;
                this.collected.prototypes.set(proto.id || path, proto);
                console.log(`  ğŸ¤– Prototype: ${proto.id}`);
            }
        } catch (e) {
            console.warn(`  âš ï¸ Could not load prototype: ${path}`);
        }
    }
    
    /**
     * Collect an object
     */
    async _collectObject(spec) {
        const id = typeof spec === 'string' ? spec : spec.id;
        const path = spec.path || id;
        
        // Objects might be inline in room files, or separate
        console.log(`  âœ¨ Object: ${id}`);
        this.collected.objects.set(id, { id, ...spec });
    }
    
    /**
     * Collect a character
     */
    async _collectCharacter(spec) {
        const id = typeof spec === 'string' ? spec : spec.id;
        console.log(`  ğŸ‘¤ Character: ${id}`);
        this.collected.characters.set(id, { id, ...spec });
    }
    
    /**
     * Collect a slideshow
     * Images served from raw.githubusercontent.com
     */
    async _collectSlideshow(spec) {
        const id = typeof spec === 'string' ? spec : spec.id;
        const path = spec.path || id;
        
        // Build image URL from raw GitHub
        const imageUrl = spec.image 
            ? `${this.baseUrl}/${path}/${spec.image}`
            : null;
        
        const slideshow = {
            id,
            path,
            title: spec.title || id,
            description: spec.description || '',
            image: spec.image,
            image_url: imageUrl,
            mining_layers: spec.mining_layers || [],
            ...spec
        };
        
        console.log(`  ğŸ–¼ï¸ Slideshow: ${id}${imageUrl ? ' (has image)' : ''}`);
        this.collected.slideshows.set(id, slideshow);
    }
    
    /**
     * Fetch a file from the base URL
     */
    async _fetchFile(path) {
        const url = `${this.baseUrl}/${path}`;
        const response = await fetch(url);
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
        }
        
        return response.text();
    }
    
    /**
     * Generate the export
     */
    async generate() {
        if (!this.manifest) {
            throw new Error('Load manifest first');
        }
        
        // Collect if not done
        if (this.collected.rooms.size === 0) {
            await this.collect();
        }
        
        // Build adventure data
        const adventure = this._buildAdventureData();
        
        // Build HTML
        const html = this._buildHTML(adventure);
        
        return {
            adventure,
            html,
            manifest: this.manifest
        };
    }
    
    /**
     * Build adventure data structure for runtime
     */
    _buildAdventureData() {
        return {
            name: this.manifest.name,
            version: this.manifest.version,
            description: this.manifest.description,
            
            _meta: {
                source: {
                    manifest: this.manifest.id,
                    generated_at: new Date().toISOString()
                },
                heritage: this.manifest.heritage,
                monetization: this.manifest.monetization
            },
            
            starting_room: this.manifest.entry.room,
            
            rooms: Array.from(this.collected.rooms.values()),
            objects: Array.from(this.collected.objects.values()),
            characters: Array.from(this.collected.characters.values()),
            archetypes: Array.from(this.collected.prototypes.values()),
            slideshows: Array.from(this.collected.slideshows.values()),
            
            features: this.manifest.features,
            views: this.manifest.views
        };
    }
    
    /**
     * Build HTML page
     */
    _buildHTML(adventure) {
        const title = this.manifest.name;
        const features = this.manifest.features;
        
        return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${title}</title>
    
    <!-- MOOLAH: Multi-Object Oriented Language and Humor Architecture -->
    <!-- NOT pay-to-play. NOT crypto. FREE! -->
    
    ${features.source_viewer ? '<link rel="stylesheet" href="source-viewer.css">' : ''}
    
    <!-- YAML parser with comment round-tripping -->
    <script src="https://cdn.jsdelivr.net/npm/yaml@2/browser/index.min.js"></script>
    
    <style>
        :root {
            --bg-dark: #1a1a2e;
            --bg-card: #16213e;
            --text-primary: #eee;
            --text-secondary: #888;
            --accent: #0f3460;
            --highlight: #e94560;
            --success: #4ecca3;
        }
        
        * { box-sizing: border-box; }
        
        body {
            font-family: 'Courier New', monospace;
            background: var(--bg-dark);
            color: var(--text-primary);
            margin: 0;
            padding: 20px;
            min-height: 100vh;
        }
        
        h1 {
            text-align: center;
            color: var(--highlight);
            margin-bottom: 10px;
        }
        
        .tagline {
            text-align: center;
            color: var(--text-secondary);
            margin-bottom: 30px;
        }
        
        .heritage {
            text-align: center;
            color: var(--success);
            font-size: 0.8em;
            margin-bottom: 20px;
        }
        
        #adventure {
            max-width: 900px;
            margin: 0 auto;
            background: var(--bg-card);
            border-radius: 8px;
            padding: 20px;
        }
        
        .free-notice {
            text-align: center;
            background: var(--success);
            color: var(--bg-dark);
            padding: 10px;
            border-radius: 4px;
            margin: 20px 0;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <h1>${title}</h1>
    <p class="tagline">${this.manifest.tagline || ''}</p>
    <p class="heritage">Heritage: Myst (1993) + The Sims (2000) = This</p>
    
    <div class="free-notice">
        ğŸ® MOOLAH â€” This is FREE. Not pay-to-play. Not crypto. Just play!
    </div>
    
    <div id="adventure">
        <!-- Adventure UI loads here -->
    </div>
    
    <!-- Runtime scripts -->
    <script src="speech.js"></script>
    <script src="adventure.js"></script>
    <script src="adventure-speech.js"></script>
    <script src="source-viewer.js"></script>
    <script src="github-api.js"></script>
    <script src="prototypes.js"></script>
    
    <script>
        // Adventure data (compiled from manifest)
        const adventureData = ${JSON.stringify(adventure, null, 2)};
        
        // Initialize
        async function init() {
            // Create engine with all features
            const engine = createSpeakingAdventure('adventure', {
                speechEnabled: ${features.speech_synthesis},
                speakRooms: true
            });
            
            await engine.load(adventureData);
            
            // Add features
            ${features.source_viewer ? `
            addViewSourceToEngine(engine, {
                namespace: { currentRepo: 'moollm', currentBranch: 'main' }
            });
            ` : ''}
            
            // Add prototypes if we have archetypes
            if (adventureData.archetypes?.length) {
                addPrototypesToEngine(engine, adventureData.archetypes);
            }
            
            window.engine = engine;
            engine.ui.printRoom(engine.world.room);
            
            console.log('ğŸ® ${title} ready!');
            console.log('   Heritage: Myst + The Sims');
            console.log('   Philosophy: FREE (not pay-to-play, not crypto)');
        }
        
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>`;
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// EXPORTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const EXPORT_COMPILER_EXPORTS = {
    ExportCompiler,
    DEFAULT_MANIFEST
};

if (typeof window !== 'undefined') {
    Object.assign(window, EXPORT_COMPILER_EXPORTS);
}

if (typeof module !== 'undefined' && module.exports) {
    module.exports = EXPORT_COMPILER_EXPORTS;
}
