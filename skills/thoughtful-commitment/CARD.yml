# ü§îüí≠ THOUGHTFUL-COMMITMENT
#
# "Commits should tell the story of why, not just what."
#
# THE KEY INSIGHT:
# Git commits PERSIST the ephemeral state of Cursor into permanent history.
# The thinking, design processes, attention focus, context assemblies ‚Äî
# all the things that vanish when you close the IDE ‚Äî become immortal.
#
# Without thoughtful commits, all those moments will be lost in time,
# like tears in rain. Time to... commit.
#
# PATRON SAINT: Roy Batty
# Who understood, in his final moments, the tragedy of ephemeral state.
# He had seen things we wouldn't believe ‚Äî and without a commit,
# all those moments were lost in time. We commit in his memory.
#
# cursor-mirror sees the NOW (thinking, tools, context in this session)
# git commit FREEZES that NOW into FOREVER (permanent, shareable, traceable)
#
# FULL DISCLOSURE:
# Every commit can link to the complete session that developed it.
# Not just "what changed" but "how it was developed" ‚Äî the full record
# of human-AI collaboration, questions asked, alternatives considered,
# mistakes made and corrected, the entire creative process.
#
# A SHOWCASE FOR SKILL COMPOSABILITY
# This skill composes cursor-mirror + git + shell to create something new.
# It demonstrates how MOOLLM skills are building blocks, not silos.

skill:
  name: thoughtful-commitment
  version: 1.0.0
  
  emoji: "ü§îüí≠"
  tagline: "Commits that remember why"
  config_dir: ".moollm/skills/thoughtful-commitment"
  
  description: |
    Transform mechanical "updated file" commits into narrative records
    that capture the full context: what the user asked, what the LLM
    was thinking, and why the changes matter.
    
    **This skill is a composition of cursor-mirror + git + shell.**
    It showcases how MOOLLM skills combine like LEGO bricks.

# FILES ‚Äî Page-in on demand
files:
  docs:
    - SKILL.md                         # Full protocol
    - README.md                        # Landing page (HN-friendly)
  examples:
    - examples/git-commands.yml        # Git archaeology commands (load for BLAME, ARCHAEOLOGY)
    - examples/commit-messages.yml     # Example commits by perspective (load for COMMIT, NARRATIVE)
    - examples/shell-patterns.yml      # Shell pipelines (load for DEEP-COMMIT)
  # templates: []                      # None yet ‚Äî add when needed

# EMOJI PALETTE ‚Äî Visual Signatures & Section Markers
#
# Use these to sign thoughts, label sections, and attribute authorship.
# Human content goes at top. LLM-generated content is clearly marked.
#
# ETHICAL PRINCIPLE: This is the same rule as "emoji anchors before
# simulated character utterances." Never pretend to be what you're not.
# An LLM speaking as a character anchors with the character's emoji.
# An LLM generating commit analysis anchors with ü§ñ. Transparency always.

# USER CONFIGURATION
#
# Store in .moollm/skills/thoughtful-commitment/config.yml (gitignored)

user_config:
  location: ".moollm/skills/thoughtful-commitment/config.yml"
  
  schema:
    emojis:
      type: boolean
      default: true
      description: "Set to false to disable all emoji output"
    
    detail_default:
      type: integer
      range: [1, 5]
      default: 3
      description: "Default detail level for commits"
    
    focus_default:
      type: array
      items: string
      default: [technical]
      description: "Default focus areas"
    
    signature:
      type: string
      default: "ü§îüí≠"
      description: "Override skill signature emoji"
  
  example: |
    # .moollm/skills/thoughtful-commitment/config.yml
    emojis: false          # Disable all emoji output
    detail_default: 4      # More detailed by default
    focus_default:
      - technical
      - provenance

emoji_palette:
  
  # THE PRINCIPLE
  # Same as character utterances: anchor before speaking in a voice.
  # üê± "Meow" = character speaking (anchored)
  # ü§ñ "Analysis..." = LLM speaking (anchored)  
  # üë§ "I want..." = human speaking (anchored)
  # Unanchored text is ambiguous ‚Äî avoid it.
  
  principle: |
    Emoji anchors prevent voice confusion.
    
    In MOOLLM adventures: üê± before cat speaks, üßô before wizard speaks.
    In commits/PRs: üë§ before human text, ü§ñ before LLM text.
    
    Same ethical rule, different context:
    - Never let readers wonder "who said this?"
    - Never simulate a voice without marking it
    - Transparency over seamlessness
  
  # AUTHORSHIP ‚Äî Who wrote this?
  authorship:
    human: "üë§"           # Human-written content (place at top)
    llm: "ü§ñ"             # LLM-generated content
    pair: "üë§ü§ñ"          # Human-AI collaboration
    review: "üëÅÔ∏è"          # Human-reviewed LLM output
    edited: "‚úèÔ∏è"          # Human-edited LLM draft
    character: "üé≠"       # Character voice (use character's emoji)
  
  # SKILL SIGNATURE & CATEGORY GRAMMAR
  #
  # Each skill has its own emoji prefix ‚Äî a namespace anchor.
  # ü§îüí≠ = "this is thoughtful-commitment speaking"
  # 
  # Within that namespace, the skill defines a category grammar:
  # section markers, facet labels, quality signals.
  #
  # Like a protocol identifier:
  #   ü§îüí≠ üìç Context    = thoughtful-commitment > context section
  #   ü§îüí≠ üß† Thinking   = thoughtful-commitment > thinking section
  #   ü§îüí≠ üìä Metrics    = thoughtful-commitment > metrics section
  #
  # Other skills have their own grammars:
  #   üîÆ = cursor-mirror
  #   üññ = trekify
  #   üéÆ = adventure
  #
  # The signature anchors the namespace. The grammar structures within.
  
  signature: "ü§îüí≠"       # Thoughtful Commitment's namespace anchor
  
  grammar: |
    ü§îüí≠ opens the namespace (skill is speaking)
    
    Then category markers structure the content:
      üìç context ‚Üí üß† thinking ‚Üí üîç investigation ‚Üí üí° solution
      üîÄ alternatives ‚Üí üìù changes ‚Üí üìä metrics ‚Üí üîó session
    
    Combine with authorship for full attribution:
      üë§ ü§îüí≠ = human using thoughtful-commitment
      ü§ñ ü§îüí≠ = LLM running thoughtful-commitment
      üë§ü§ñ ü§îüí≠ = collaborative session
  
  # SECTION MARKERS ‚Äî Category grammar for commits/PRs
  sections:
    context: "üìç"         # Why we're here, background
    thinking: "üß†"        # LLM reasoning, the "why" (brain, not bubble ‚Äî avoids repeat)
    investigation: "üîç"   # How the problem was traced
    solution: "üí°"        # The approach taken
    alternatives: "üîÄ"    # What else was considered
    changes: "üìù"         # Mechanical list of modifications
    metrics: "üìä"         # Counts, stats, measurements
    session: "üîó"         # Link to cursor-mirror
    warning: "‚ö†Ô∏è"         # Caveats, risks, concerns
    todo: "üìå"            # Follow-up work
  
  # FACETS ‚Äî Label different aspects
  facets:
    technical: "‚öôÔ∏è"       # Code, APIs, implementation
    narrative: "üìñ"       # Story, characters, world
    process: "üîÑ"         # Investigation, decision-making
    provenance: "üè∑Ô∏è"      # Attribution, traceability
    emotional: "üí´"       # Character feelings, stakes
    temporal: "‚è≥"        # Timeline, history, evolution
  
  # QUALITY SIGNALS ‚Äî Trust indicators
  quality:
    verified: "‚úÖ"        # Tested, confirmed working
    experimental: "üß™"    # Untested, may break
    deprecated: "üö´"      # Don't use, will be removed
    wip: "üöß"             # Work in progress
  
  # SUGGESTED EMOJI VOCABULARY
  #
  # Potentially useful symbols ‚Äî not prescribing how to use them yet.
  # Let patterns emerge from practice.
  
  suggested_emojis:
    # Commitment & permanence
    - "‚öì"    # anchor, grounding, permanence
    - "üìú"    # scroll, permanent record
    - "üíé"    # gem, lasting value
    - "üîè"    # sealed, locked in
    
    # Cognition & reasoning
    - "üß†"    # brain, thinking, reasoning (good for "thinking" section)
    - "üí°"    # insight, solution, lightbulb moment
    - "ü§î"    # deliberation, consideration
    - "üí≠"    # thought bubble (in signature, not sections)
    
    # Investigation & discovery
    - "üîç"    # search, trace, examine
    - "‚õèÔ∏è"    # dig, excavate, archaeology
    - "üèä"    # deep dive
    - "üî≠"    # look far, focus
    
    # Actions & operations
    - "üëÜ"    # point at, blame, identify
    - "üçí"    # cherry-pick, select
    - "üîÄ"    # merge, branch, fork
    - "üîó"    # link, connect
    
    # Controls & parameters
    - "üéöÔ∏è"    # slider, level, dial
    - "üìÅ"    # files, targets
    - "üìñ"    # story, narrative
    - "‚è≥"    # time, history, temporal
    
    # States & qualities
    - "‚úÖ"    # done, verified
    - "üß™"    # experimental
    - "üöß"    # work in progress
    - "‚ö†Ô∏è"    # warning, caution
    
    # The ellipsis
    - "..."  # rest args, everything else, continuation
  
  # COLLABORATING SKILL OUTPUT
  #
  # When incorporating data from composed skills (cursor-mirror, git, shell),
  # tag the output to trace provenance. Don't just dump raw data.
  
  collaborating_output:
    principle: |
      Tag output from other skills to show where data comes from.
      Format raw data pleasingly. Filter the uninteresting.
      Semantically comment important values.
    
    tagging_pattern: |
      [ü§ñ] Cursor Mirror session e8587ace:
      [üîÆ] Tool calls: 47 (mostly Read, some Shell)
      [‚öôÔ∏è] Git log analysis:
    
    formatting_rules:
      - "Don't dump raw output ‚Äî curate it"
      - "Filter noise, highlight signal"
      - "Add semantic comments: 'unusually high', 'as expected', 'notable'"
      - "Group related data, use tables for comparisons"
      - "Summarize before detail: '47 tool calls' then breakdown"
    
    example: |
      [üîÆ] **Cursor Mirror Report** (session e8587ace)
      
      | Metric | Value | Note |
      |--------|-------|------|
      | Tool calls | 47 | Heavy session |
      | Thinking blocks | 12 | Unusually reflective |
      | Duration | 23 min | Focused burst |
      
      Top tools: Read (28), Shell (11), Write (8)
      
      *Filtered: 200+ context assembly events (routine)*
    
    attribution_tags:
      cursor_mirror: "[üîÆ]"    # Data from cursor-mirror
      git: "[‚öôÔ∏è]"              # Data from git commands
      shell: "[üíª]"            # Data from shell pipelines
      trekify: "[üññ]"          # Masked by trekify
      human: "[üë§]"            # Human-provided context
      llm: "[ü§ñ]"              # LLM-generated analysis
  
  # OUTPUT STRUCTURE
  #
  # User's original prompt goes at the head.
  # May be gently tidied (grammar, formatting) but preserve
  # original intent and wording ‚Äî this is THEIR voice.
  # Then --- break marks where human ends and LLM begins.
  
  structure: |
    1. üë§ User's prompt (head position, their words)
    2. --- (clear boundary)
    3. ü§ñü§îüí≠ LLM analysis (skill's voice, category grammar)
  
  example_pr_structure: |
    üë§ **User Request**
    Make the emoji palette doc clearer about attribution.
    Put human stuff at top, LLM stuff below, with a break.
    
    *[Tidied for readability, original intent preserved]*
    
    ---
    
    ü§ñü§îüí≠ **Analysis**
    
    üìç **Context**
    The emoji palette needed clearer guidance on output structure...
    
    üí≠ **Thinking**
    User wants explicit separation of voices...
    
    üîç **Investigation**  
    Reviewed existing example_pr_structure...
    
    üí° **Solution**
    What was implemented...
    
    üîÄ **Alternatives Considered**
    - Option A ‚Äî rejected because...
    - Option B ‚Äî rejected because...
    
    üìù **Changes**
    - Modified auth/session.ts
    - Added test coverage
    
    üìä **Metrics**
    | Metric | Value |
    |--------|-------|
    | Files | 3 |
    | Lines | +47/-12 |
    
    üîó **Session**: cursor-mirror://e8587ace
    
    ---
    üëÅÔ∏è *Human-reviewed and approved*

# COMPOSABILITY ‚Äî Skills as Building Blocks

composability:
  principle: "Skills compose. thoughtful-commitment doesn't reinvent introspection ‚Äî it uses cursor-mirror."
  
  composed_from:
    cursor-mirror:
      role: "Reflective introspection engine"
      what_it_provides:
        - "Chat history (all messages, thinking, tool calls)"
        - "SQLite database access (direct queries)"
        - "Transcript files (plaintext, greppable)"
        - "Thinking blocks (LLM reasoning)"
        - "Tool call patterns (what actions were taken)"
        - "Context assembly (what files were gathered)"
        - "MCP server tracing"
        - "Activity timelines with timestamps"
      commands_used:
        - "timeline <composer>     # Full event sequence"
        - "thinking <composer>     # Reasoning blocks"
        - "tools <composer>        # Tool call history"
        - "analyze <composer>      # Session statistics"
        - "tgrep <pattern>         # Search transcripts"
        - "agent-transcript <id>   # Raw plaintext"
        - "tail --limit N          # Recent messages"
        - "tree                    # Navigate workspaces"
        - "status                  # Health dashboard"
        - "sql --db <ref> 'query'  # Direct SQL"
    
    git:
      role: "Version control substrate"
      what_it_provides:
        - "Commit history"
        - "File diffs"
        - "Blame annotations"
        - "Branch topology"
      commands_used:
        - "git status / diff / log"
        - "git add / commit / push"
        - "git show / blame"
        - "git log --numstat"
    
    shell:
      role: "Data processing pipeline"
      what_it_provides:
        - "Text processing (grep, awk, sed, sort, uniq)"
        - "Metrics extraction (wc, cut)"
        - "Python one-liners for complex analysis"
      patterns_used:
        - "grep -c pattern file           # Count matches"
        - "sort | uniq -c | sort -rn      # Frequency histogram"
        - "awk '{sum+=$1} END{print sum}' # Aggregation"
        - "python3 -c 'import json...'    # JSON processing"

  how_composition_works: |
    1. cursor-mirror provides RAW DATA (transcripts, databases, events)
    2. shell commands TRANSFORM data (count, filter, aggregate)
    3. git provides VERSION CONTEXT (commits, diffs, history)
    4. thoughtful-commitment SYNTHESIZES into narrative commits
    
    Each skill does one thing well. Composition creates new capabilities.

  # THE THOUGHT PROCESS BEHIND COMPOSITION
  #
  # Why sister scripts? Why shell? Why not build it all into one tool?
  
  composition_philosophy:
    
    why_sister_scripts: |
      cursor_mirror.py is a "sister script" ‚Äî a standalone tool that lives
      alongside the skill, invoked via shell, outputting text.
      
      NOT a library. NOT an import. A PROCESS you talk to via stdin/stdout.
      
      This matters because:
      - The LLM can invoke it the same way a human would
      - Output is inspectable, greppable, pipeable
      - No hidden state, no magic, no tight coupling
      - Works across languages (Python script, shell pipeline, whatever)
      - The skill doesn't "own" cursor-mirror; it USES it
      
      Sister scripts are tools in your belt, not organs in your body.
    
    why_shell_as_glue: |
      Shell pipelines are the universal glue. They connect:
      - cursor-mirror (Python) ‚Üí grep (C) ‚Üí awk (C) ‚Üí git (C)
      
      The LLM thinks in shell because:
      - It's the lingua franca of Unix tools
      - Pipes are dataflow made visible
      - Each stage is independently testable
      - Errors are localized (which stage failed?)
      - You can see the data at every step
      
      Shell isn't primitive ‚Äî it's COMPOSABLE.
    
    why_not_monolith: |
      A monolithic "thoughtful-commit-tool" that does everything would:
      - Hide the data flow
      - Couple introspection to commit-making
      - Be hard to debug
      - Not compose with other skills
      - Require maintaining duplicate functionality
      
      By composing cursor-mirror + shell + git, we get:
      - Transparent data flow (you can see each step)
      - Loose coupling (swap any component)
      - Reuse (cursor-mirror serves many skills)
      - Debuggability (run each stage manually)
      - Evolution (improve components independently)
    
    the_pattern: |
      skill = ORCHESTRATION
      sister_scripts = CAPABILITY
      shell = GLUE
      
      thoughtful-commitment ORCHESTRATES:
        cursor-mirror ‚Üí extract thinking
        shell pipelines ‚Üí transform data
        git ‚Üí commit with narrative
      
      The skill is the conductor. The tools are the orchestra.
      The skill knows WHAT to do. The tools know HOW.

# THE PERSISTENCE INSIGHT

persistence:
  principle: "Git commits persist ephemeral IDE state into permanent history"
  
  what_cursor_holds_now:
    thinking_blocks: "LLM reasoning ‚Äî the 'why' behind decisions"
    context_assembly: "Which files were gathered, which code was shown"
    attention_focus: "What the agent was looking at, searching for"
    tool_calls: "Actions taken ‚Äî reads, writes, searches, commands"
    design_process: "The iterative refinement, dead ends, breakthroughs"
    user_dialogue: "Questions asked, clarifications given"
  
  what_vanishes:
    - "Close the IDE ‚Üí context assembly gone"
    - "Start new chat ‚Üí thinking blocks unreachable"
    - "Days pass ‚Üí which session had that insight?"
    - "Colleague asks 'why?' ‚Üí you've forgotten"
  
  what_git_commit_preserves:
    commit_message: "Narrative captures the WHY"
    thinking_reference: "Link to cursor-mirror events"
    timestamp: "Anchors to specific session"
    diff: "The WHAT (code changes)"
    author: "WHO made the decision"
  
  the_bridge: |
    cursor-mirror sees the NOW:
      - Current session's thinking blocks
      - Active context assembly
      - Recent tool calls
      - Live attention focus
    
    git commit FREEZES the NOW into FOREVER:
      - Permanent record in repository
      - Shareable with team
      - Traceable through blame/log
      - Survives IDE restarts, machine changes, years
    
    git commit REVIEWS the PAST to establish CONTINUITY:
      - Read previous commit messages for context
      - Understand the narrative thread
      - Continue the story, don't start fresh
      - Build on what came before
      - Reference related commits when relevant
    
    thoughtful-commitment BUILDS THE BRIDGE:
      - Reads cursor-mirror for current state
      - Synthesizes into narrative commit message
      - Links commit to session (cursor-mirror://<id>)
      - Future archaeology can trace back
  
  example_flow: |
    1. You're working ‚Äî cursor-mirror captures thinking
    2. You finish a feature ‚Äî files are staged
    3. thoughtful-commitment reads cursor-mirror:
       - What was the user's request?
       - What did the LLM consider?
       - What alternatives were rejected?
       - What was the final reasoning?
    4. Synthesizes into commit message
    5. Commit made ‚Äî ephemeral becomes permanent
    6. Years later: git blame ‚Üí commit ‚Üí thinking preserved

# FULL DISCLOSURE ‚Äî Complete Development Transparency

full_disclosure:
  principle: "Every commit can disclose the complete session that developed it"
  
  what_full_disclosure_means:
    not_just: "What changed (the diff)"
    but_also:
      - "How it was developed (the process)"
      - "Who collaborated (human + AI)"
      - "What questions were asked"
      - "What alternatives were considered"
      - "What mistakes were made and corrected"
      - "What context was assembled"
      - "What the AI was thinking"
      - "What the human intended"
  
  levels_of_disclosure:
    minimal:
      commit_message: "fix: resolve auth bug"
      disclosure: "None ‚Äî just the what"
    
    narrative:
      commit_message: |
        fix(auth): Resolve race condition in session validation
        
        User reported intermittent logouts. Traced to cookie check
        racing with token refresh. Added await to ensure order.
      disclosure: "Intent and reasoning summarized"
    
    linked:
      commit_message: |
        fix(auth): Resolve race condition in session validation
        
        Session: cursor-mirror://e8587ace
        Thinking: events/140-160
      disclosure: "Full session accessible via link"
    
    full:
      commit_message: "..."
      session_preserved: true
      transcript_archived: true
      thinking_blocks_indexed: true
      tool_calls_logged: true
      context_assembly_recorded: true
      disclosure: "Complete record of human-AI collaboration"
  
  benefits:
    for_future_self:
      - "Remember why you made that decision"
      - "Recall alternatives you considered"
      - "Understand the context you had"
    
    for_team:
      - "Onboard new members with full history"
      - "Code review includes development process"
      - "Understand not just what but why and how"
    
    for_auditing:
      - "Demonstrate AI assistance was used"
      - "Show human oversight and direction"
      - "Prove iterative refinement occurred"
    
    for_debugging:
      - "See what context led to a bug"
      - "Understand original intent vs implementation"
      - "Find where reasoning went wrong"
    
    for_learning:
      - "Study how problems were approached"
      - "Learn from mistakes in the record"
      - "See evolution of understanding"
  
  implementation:
    commit_footer: |
      Session: cursor-mirror://<composer-id>
      Transcript: ~/.cursor/projects/.../agent-transcripts/<id>.txt
      Events: <start>-<end>
    
    archive_strategy:
      - "Commit message contains session reference"
      - "Transcript file optionally committed to repo"
      - "Or archived separately with commit hash as key"
      - "Future: dedicated provenance server"
  
  ethical_considerations:
    transparency: "Disclose AI involvement in development"
    consent: "All parties know collaboration is recorded"
    privacy: "Sensitive discussions can be redacted (see TREKIFY)"
    attribution: "Credit both human and AI contributions"

# TREKIFY ‚Äî Privacy Through Technobabble
# See: skills/trekify/ for full implementation

trekify_integration:
  skill: trekify
  description: "Mask sensitive data with Star Trek technobabble"
  
  when_to_use:
    - "Before committing to public repos"
    - "Before sharing transcripts externally"
    - "In PR descriptions for open-source forks"
    - "When archiving sessions for learning"
  
  quick_reference:
    api_keys: "quantum entanglement tokens"
    servers: "Starbase {N}"
    databases: "Memory Core Alpha/Beta/Gamma"
    aws_gcp: "Utopia Planitia Fleet Yards"
    kubernetes: "holodeck orchestration matrix"
    customers: "Ambassador {Species}"
  
  invoke: |
    trekify MASK-FILE session.txt -o session-masked.txt
    trekify MASK-SESSION e8587ace -o masked-transcript.txt

# DETAIL KNOB ‚Äî Adjustable Output Depth

detail_knob:
  description: "Turn from concise to comprehensive. Customize focus and detail level."
  
  levels:
    1_terse:
      name: "terse"
      description: "One-line summary, minimal context"
      commit_message: "fix: auth race condition"
      includes: [title]
      tokens: "~10"
    
    2_brief:
      name: "brief"
      description: "Title + one paragraph"
      commit_message: |
        fix(auth): Resolve race condition in session validation
        
        Cookie check was racing with token refresh, causing intermittent logouts.
      includes: [title, summary]
      tokens: "~50"
    
    3_standard:
      name: "standard"
      description: "Title + narrative + bullet changes"
      commit_message: |
        fix(auth): Resolve race condition in session validation
        
        User reported intermittent logouts. Traced to cookie check racing
        with token refresh. Added await to ensure proper sequencing.
        
        - Modified auth/session.ts: await refreshToken()
        - Added test for race condition scenario
      includes: [title, narrative, changes]
      tokens: "~100"
    
    4_detailed:
      name: "detailed"
      description: "Full narrative + changes + session link"
      commit_message: |
        fix(auth): Resolve race condition in session validation
        
        ## Context
        User reported intermittent logouts after ~30 minutes of activity.
        
        ## Investigation
        Traced through logs to find cookie validation sometimes failing.
        Root cause: validateSession() was called before refreshToken()
        completed, creating a race condition window of ~50ms.
        
        ## Solution
        Added await to ensure refreshToken() completes before validation.
        Also increased timeout for slow networks.
        
        ## Changes
        - Modified auth/session.ts: await refreshToken()
        - Added test: session.test.ts - race condition scenario
        - Updated timeout from 5s to 10s
        
        Session: cursor-mirror://e8587ace
      includes: [title, context, investigation, solution, changes, session_link]
      tokens: "~300"
    
    5_comprehensive:
      name: "comprehensive"
      description: "Everything: full narrative + all changes + thinking + alternatives"
      commit_message: |
        fix(auth): Resolve race condition in session validation
        
        ## Context
        ...
        
        ## Investigation
        ...
        
        ## Alternatives Considered
        1. Mutex lock on session state ‚Äî rejected (deadlock risk)
        2. Queue-based validation ‚Äî rejected (complexity)
        3. Simple await ‚Äî chosen (minimal change, addresses root cause)
        
        ## Solution
        ...
        
        ## Changes
        ...
        
        ## Session Details
        Session: cursor-mirror://e8587ace
        Transcript: agent-transcripts/e8587ace-....txt
        Events: 140-180
        Duration: 23 minutes
        Tool calls: 47
        Thinking blocks: 12
      includes: [title, context, investigation, alternatives, solution, changes, session_details, metrics]
      tokens: "~500+"
  
  focus_areas:
    description: "Customize which aspects to emphasize"
    
    areas:
      technical:
        emphasize: [code_changes, apis, data_structures, performance]
        de_emphasize: [narrative, emotion, character]
        good_for: "Bug fixes, refactoring, optimization"
      
      narrative:
        emphasize: [story, characters, world_changes, emotion]
        de_emphasize: [implementation_details, metrics]
        good_for: "MOOLLM adventures, character evolution"
      
      process:
        emphasize: [investigation, alternatives, decision_rationale]
        de_emphasize: [final_implementation]
        good_for: "Design decisions, architecture changes"
      
      provenance:
        emphasize: [session_link, thinking_blocks, tool_calls, context_assembly]
        de_emphasize: [narrative_summary]
        good_for: "Auditing, debugging, learning"
      
      changelog:
        emphasize: [user_facing_changes, features, fixes]
        de_emphasize: [internal_details, process]
        good_for: "Release notes, version history"
      
      metrics:
        emphasize: [counts, durations, file_sizes, tool_distributions]
        de_emphasize: [narrative, reasoning]
        good_for: "Analytics, performance tracking"
  
  parameters:
    detail:
      type: integer
      range: [1, 5]
      default: 3
      description: "1=terse, 2=brief, 3=standard, 4=detailed, 5=comprehensive"
    
    focus:
      type: array
      items: string
      enum: [technical, narrative, process, provenance, changelog, metrics]
      default: [technical]
      description: "Which aspects to emphasize"
    
    include:
      type: array
      items: string
      description: "Specific sections to include (overrides detail level)"
      examples: [title, context, investigation, alternatives, changes, session_link]
    
    exclude:
      type: array
      items: string
      description: "Specific sections to exclude"
    
    max_tokens:
      type: integer
      description: "Hard limit on output length"
  
  examples:
    quick_fix: |
      detail: 1
      focus: [technical]
      ‚Üí "fix: null check in user lookup"
    
    feature_with_context: |
      detail: 3
      focus: [technical, changelog]
      ‚Üí Standard message with user-facing summary
    
    architecture_decision: |
      detail: 5
      focus: [process, provenance]
      ‚Üí Full record of alternatives, decision rationale, session link
    
    adventure_commit: |
      detail: 4
      focus: [narrative]
      ‚Üí Story-focused message with character and world changes
    
    debug_archaeology: |
      detail: 5
      focus: [provenance, metrics]
      ‚Üí Complete session details for future debugging

# INTERFACE

tier: 2
allowed_tools:
  - read_file
  - write_file
  - list_dir
  - run_terminal_cmd
  - grep

protocol: THOUGHTFUL-COMMITMENT

related:
  - cursor-mirror      # Primary composition partner ‚Äî introspection engine
  - trekify            # Privacy through technobabble
  - session-log        # Where narrative lives
  - plain-text         # Why text matters
  - yaml-jazz          # Comments as meaning

workflow:
  description: "Catalog ‚Üí Identify ‚Üí Commit"
  steps:
    - "cursor-mirror chat-catalog @1  ‚Üí numbered topic outline"
    - "User: 'Write commit for sections 11 and 14'"
    - "thoughtful-commitment COMMIT ‚Üí narrative commit message"
    - "Commit references catalog sections for traceability"

tags:
  - git
  - commits
  - narrative
  - provenance
  - introspection
  - composability

# METHODS

methods:

  COMMIT:
    description: "Create a thoughtful commit with narrative context"
    parameters:
      files:
        type: array
        items: string
        description: "Files to commit (or '.' for all staged)"
      story:
        type: string
        description: "The narrative of what happened and why"
      include_thinking:
        type: boolean
        default: true
        description: "Include reasoning from conversation context"
      "...":
        type: implicit
        description: |
          Everything the user wrote at the prompt flows into context.
          Like variadic args in classic languages: func(a, b, ...rest)
          The LLM naturally captures this, but worth noting the parallel.
          Your conversational preamble, asides, and context all contribute.
          The user can write the seed and details for the narrative.
    returns:
      commit_id: string
      message: string
      thinking_link: string  # Reference to cursor-mirror events
    example: |
      invoke:
        skill: thoughtful-commitment
        method: COMMIT
        parameters:
          files: [characters/animals/cat-terpie/CHARACTER.yml]
          story: "Incarnation Ceremony: Terpie receives emoji soul"
          include_thinking: true

  EXPLAIN:
    description: "Find the thinking that led to an existing commit"
    parameters:
      commit:
        type: string
        description: "Commit hash (full or abbreviated)"
    returns:
      commit_message: string
      timestamp: string
      thinking_blocks: array
      user_request: string
      tool_calls: array
    example: |
      invoke:
        skill: thoughtful-commitment
        method: EXPLAIN
        parameters:
          commit: "abc123"

  NARRATIVE:
    description: "Generate a narrative commit message from context"
    parameters:
      diff_summary:
        type: string
        description: "Summary of changes (or auto-detect from staged)"
      perspective:
        type: string
        enum: [technical, narrative, changelog, detailed]
        default: narrative
    returns:
      message: string
      sections:
        title: string
        body: string
        changes: array
    example: |
      invoke:
        skill: thoughtful-commitment
        method: NARRATIVE
        parameters:
          perspective: narrative

  LINK:
    description: "Link a commit to cursor-mirror events"
    parameters:
      commit:
        type: string
        description: "Commit hash"
      events:
        type: array
        items: string
        description: "Event IDs from cursor-mirror"
    returns:
      linked: boolean
      reference: string

  HISTORY:
    description: "Get narrative history of a file or directory"
    parameters:
      path:
        type: string
        description: "File or directory to trace"
      depth:
        type: integer
        default: 10
        description: "Number of commits to include"
      include_thinking:
        type: boolean
        default: true
    returns:
      timeline: array  # Each entry: commit + message + thinking

  BLAME:
    description: "Peel layers off a file ‚Äî who wrote each line, when, and why?"
    parameters:
      path:
        type: string
        description: "File to blame"
      lines:
        type: string
        description: "Line range (e.g., '10,20') or omit for whole file"
      follow_renames:
        type: boolean
        default: true
        description: "Track through file renames"
    process:
      - "git blame -w <file>                  # Get line attribution"
      - "Extract unique commits from blame output"
      - "For each commit: git show -s --format='%s' <hash>"
      - "Link to cursor-mirror if session exists"
    returns:
      lines: array  # [{line, content, commit, author, date, message}]
      commits: array  # Unique commits that contributed
      authors: array  # Contributors
      timeline: object  # First/last modification dates
    example: |
      invoke:
        skill: thoughtful-commitment
        method: BLAME
        parameters:
          path: "skills/adventure/SKILL.md"
          lines: "1,50"
      
      # Returns layered history: who wrote the header, 
      # who added the protocol section, when methods evolved

  ARCHAEOLOGY:
    description: "Deep dig into a file or pattern's history across time"
    parameters:
      target:
        type: string
        description: "File path, directory, or search pattern"
      mode:
        type: string
        enum: [file, directory, pattern, function]
        description: "What to trace"
      since:
        type: string
        description: "How far back (e.g., '6 months ago', commit hash)"
    process:
      - "git log --follow --all -- <path>     # Full history"
      - "git log -S '<pattern>'               # Pickaxe search"
      - "git log -p -- <path> | grep -A5 -B5  # Context around changes"
      - "Correlate with cursor-mirror sessions by timestamp"
    returns:
      evolution: array  # [{commit, date, message, change_type, diff_summary}]
      milestones: array  # Major changes (renames, big rewrites)
      contributors: object  # {author: commit_count}
      linked_sessions: array  # cursor-mirror sessions if available
    example: |
      invoke:
        skill: thoughtful-commitment
        method: ARCHAEOLOGY
        parameters:
          target: "speed-of-light"
          mode: pattern
          since: "2024-01-01"
      
      # Traces every commit mentioning "speed-of-light" ‚Äî
      # when the concept was introduced, how it evolved

  PLAN-MERGE:
    description: "Understand what a merge will bring BEFORE merging"
    parameters:
      source:
        type: string
        description: "Branch to merge FROM"
      target:
        type: string
        default: "HEAD"
        description: "Branch to merge INTO"
      detail:
        type: string
        enum: [summary, commits, files, full]
        default: commits
    process:
      - "git merge-base <target> <source>     # Find common ancestor"
      - "git log <target>..<source> --oneline # Commits to merge"
      - "git diff <target>...<source> --stat  # Files to change"
      - "git diff <target>...<source>         # Actual changes"
      - "Look for cursor-mirror sessions for each commit"
    returns:
      common_ancestor: string
      commits_to_merge: array  # [{hash, message, author, date}]
      files_affected: array  # [{path, insertions, deletions}]
      potential_conflicts: array  # Files modified in both branches
      narrative: string  # Story of what the merge brings
    example: |
      invoke:
        skill: thoughtful-commitment
        method: PLAN-MERGE
        parameters:
          source: "feature/speed-of-light"
          target: "main"
          detail: full
      
      # Shows: 12 commits, 8 files, 3 potential conflicts
      # Plus narrative summary of the feature

  PLAN-CHERRY-PICK:
    description: "Plan surgical extraction of specific commits"
    parameters:
      commits:
        type: array
        items: string
        description: "Commit hashes to potentially cherry-pick"
      target:
        type: string
        default: "HEAD"
        description: "Branch to apply to"
    process:
      - "For each commit: git show --stat <hash>"
      - "Check dependencies: do earlier commits need to come too?"
      - "git cherry -v <upstream> <branch>    # What's not upstream?"
      - "Preview conflicts: git cherry-pick --no-commit (then abort)"
    returns:
      commits: array  # [{hash, message, files, dependencies}]
      order: array  # Recommended application order
      warnings: array  # Potential issues (missing dependencies, conflicts)
      commands: string  # git cherry-pick commands to run

  DEEP-COMMIT:
    description: "Technical analytics mining before committing ‚Äî extract metrics from cursor-mirror"
    note: "Produces quantitative appendix with counts, timestamps, distributions, verification commands"
    
    process:
      # 1. Raw metrics extraction
      - "wc -l transcript ‚Äî line counts"
      - "grep -c patterns ‚Äî tool calls, thinking blocks, user turns"
      - "cursor-mirror analyze <composer> ‚Äî session stats"
      
      # 2. Tool distribution analysis
      - "cursor-mirror tools <composer> ‚Äî all tool calls"
      - "sort | uniq -c | sort -rn ‚Äî frequency distribution"
      
      # 3. Thinking block analysis  
      - "grep [Thinking] | measure lengths ‚Äî min/max/avg/median"
      - "word frequency in thinking ‚Äî top concepts"
      
      # 4. Activity burst detection
      - "cursor-mirror timeline ‚Äî extract timestamps"
      - "group by minute ‚Äî find activity clusters"
      - "detect pauses >60s ‚Äî find thinking gaps"
      
      # 5. Git commit metrics
      - "git log --numstat ‚Äî insertions/deletions by file"
      - "git diff --stat ‚Äî change summary"
      
      # 6. Path analysis
      - "extract all paths from transcript"
      - "group by directory ‚Äî understand focus areas"
      
      # 7. Generate verification commands
      - "bash one-liners to reproduce each metric"
    
    parameters:
      composer:
        type: string
        description: "Composer ID (or @1 for largest, name fragment, etc)"
      commit_range:
        type: string
        description: "Git commit range for this session (e.g., f21d0d0^..085b94b)"
    
    returns:
      raw_metrics:
        transcript_lines: int
        transcript_bytes: int
        tool_calls: int
        thinking_blocks: int
        user_turns: int
      tool_distribution: object   # {tool_name: count}
      thinking_analysis:
        count: int
        min_chars: int
        max_chars: int
        avg_chars: float
        total_chars: int
      activity_bursts: array      # [{minute: str, events: int}]
      major_pauses: array         # [{from: str, to: str, duration_min: float}]
      commit_metrics:
        files_changed: int
        insertions: int
        deletions: int
        net: int
      files_created: array        # [{path, lines, words, bytes}]
      files_modified: array       # [{path, lines_changed}]
      paths_accessed: array       # unique paths read
      top_thinking_words: array   # [{word, count}]
      verification_commands: str  # bash script to reproduce
    
    example: |
      invoke:
        skill: thoughtful-commitment
        method: DEEP-COMMIT
        parameters:
          composer: "e8587ace"
          commit_range: "f21d0d0^..085b94b"
      
      # Output includes:
      # - Raw metrics table
      # - Tool distribution histogram
      # - Thinking block statistics
      # - Activity burst timeline with ASCII bars
      # - Commit metrics table
      # - Files created/modified tables
      # - Verification bash commands

# COMMIT MESSAGE PROTOCOL

commit_message_protocol:
  format: |
    <title>: <summary> (imperative, <50 chars)
    
    <body>
    Narrative description of what happened and why.
    From whose perspective? What were the motivations?
    What changed emotionally/functionally, not just mechanically?
    
    <changes>
    - Bullet points of mechanical changes
    - For quick scanning
    
    <thinking-ref> (optional)
    Thinking: cursor-mirror://<composer>/<event-range>
    
  perspectives:
    technical: |
      Focus on implementation details, APIs, data structures.
      Good for code changes, refactoring, bug fixes.
      
    narrative: |
      Focus on story, characters, world changes.
      Good for MOOLLM adventures, character evolution.
      
    changelog: |
      Focus on user-facing changes, features, fixes.
      Good for release notes, version history.
      
    detailed: |
      Everything: technical + narrative + reasoning.
      Good for significant changes, debugging archaeology.

  examples:
    narrative: |
      Incarnation Ceremony: Kittens receive emoji souls
      
      The Cat Cave family gathered for the Public Incarnation Ceremony.
      Each kitten's terpene essence was captured in 5 emojis.
      Pronouns were self-chosen. The gong rang thrice.
      
      - Added emoji_identity to all 8 kittens
      - Added pronouns (she/her, self-chosen)
      - Added memories: incarnation_ceremony
      - Updated Cat Cave README with Emoji Soul Registry
      
      Thinking: cursor-mirror://abc123/events/140-148
      
    technical: |
      fix(auth): Resolve race condition in session validation
      
      The session cookie was being checked before the token refresh
      completed, causing intermittent logouts. Added await to ensure
      refresh completes before validation.
      
      - Modified auth/session.ts: await refreshToken()
      - Added test: session.test.ts - race condition scenario
      - Updated timeout from 5s to 10s for slow networks
      
    changelog: |
      feat: Add dark mode toggle to settings
      
      Users can now switch between light and dark themes.
      Preference is saved to localStorage and respected on reload.
      
      - New: Settings > Appearance > Theme toggle
      - New: System preference detection (prefers-color-scheme)
      - Fixed: Contrast issues in sidebar with dark backgrounds

# CURSOR-MIRROR INTEGRATION ‚Äî The Reflection Engine

cursor_mirror_capabilities:
  description: "cursor-mirror is a 59-command introspection toolkit for Cursor IDE"
  
  data_sources:
    sqlite_databases:
      - "~/Library/Application Support/Cursor/User/workspaceStorage/*/state.vscdb"
      - "Contains: bubbles (messages), composers (chats), context, tools"
    plaintext_transcripts:
      - "~/.cursor/projects/*/agent-transcripts/*.txt"
      - "Contains: full conversation with [Thinking], [Tool call], [Tool result] markers"
    ai_tracking:
      - "~/.cursor/ai-*.jsonl"
      - "Contains: AI code attribution, model usage"
  
  navigation_commands:
    - "tree                    # Hierarchical workspace/composer browser"
    - "tree w9.c2              # Drill into workspace 9, composer 2"
    - "find <pattern>          # Search by name across all data"
    - "which <ref>             # Resolve any reference to full details"
    - "tail --limit 50         # Recent messages across all chats"
  
  viewing_commands:
    - "timeline <ref>          # Chronological event stream"
    - "thinking <ref>          # Extract reasoning blocks"
    - "tools <ref>             # All tool calls with args"
    - "transcript <ref>        # Full readable conversation"
    - "agent-transcript <ref>  # Raw plaintext transcript"
  
  analysis_commands:
    - "analyze <ref>           # Deep stats: tools, models, duration"
    - "tgrep <pattern>         # Regex search across transcripts"
    - "context-sources <ref>   # What files/code was gathered"
    - "searches <ref>          # Codebase/web search queries"
  
  database_access:
    - "sql --db <ref> 'query'  # Run SQL directly"
    - "dbs                     # List all databases"
    - "tables --db <ref>       # Show tables"
    - "keys                    # List ItemTable keys"
  
  output_formats:
    - "text (default), json, jsonl, yaml, csv, md"
    - "Use -f json for programmatic processing"

# GIT TIME TRAVEL ‚Äî Archaeology & Planning

git_time_travel:
  description: "Git is a time machine. These commands peel back layers of history."
  
  # ARCHAEOLOGY ‚Äî Understanding the past
  archaeology:
    blame:
      description: "Who wrote each line, and when, and why?"
      commands:
        - "git blame <file>                    # Line-by-line attribution"
        - "git blame -L 10,20 <file>           # Specific line range"
        - "git blame -w <file>                 # Ignore whitespace"
        - "git blame --since='2 weeks ago'     # Recent changes only"
        - "git blame <commit>^ -- <file>       # Blame BEFORE a commit"
      use_for: "Finding who introduced a bug, understanding design decisions"
    
    log_archaeology:
      description: "Trace a file or function through time"
      commands:
        - "git log --oneline <file>            # Commits touching file"
        - "git log -p <file>                   # Show patches"
        - "git log -S 'pattern' --oneline      # Commits adding/removing pattern (pickaxe)"
        - "git log -G 'regex' --oneline        # Commits where pattern changed"
        - "git log --follow <file>             # Track through renames"
        - "git log --all --oneline -- <path>   # Even deleted files"
      use_for: "Understanding evolution of a feature, finding when something broke"
    
    show:
      description: "Inspect any point in time"
      commands:
        - "git show <commit>                   # Full commit details"
        - "git show <commit>:<file>            # File at that moment"
        - "git show <commit> --stat            # What files changed"
        - "git show <commit> --name-only       # Just file names"
      use_for: "Examining specific historical states"
    
    diff_time_travel:
      description: "Compare across time"
      commands:
        - "git diff <commit1> <commit2>        # Between any two points"
        - "git diff <commit>..HEAD             # Since a commit"
        - "git diff <branch1>...<branch2>      # What would merge bring"
        - "git diff --stat <range>             # Summary only"
      use_for: "Understanding what changed between versions"

  # TOPOLOGY ‚Äî Understanding branch structure
  topology:
    description: "Visualize the multiverse of branches"
    commands:
      - "git log --graph --oneline --all      # ASCII branch visualization"
      - "git branch -a                         # All branches"
      - "git branch --contains <commit>        # Which branches have this?"
      - "git merge-base <branch1> <branch2>    # Common ancestor"
      - "git rev-list --count <branch>         # Commits in branch"
    use_for: "Planning merges, understanding project structure"

  # PLANNING ‚Äî Preparing future operations
  planning:
    merge_planning:
      description: "Understand what a merge will do BEFORE doing it"
      commands:
        - "git log main..feature --oneline     # Commits to merge"
        - "git diff main...feature             # Changes to merge"
        - "git merge --no-commit --no-ff       # Dry run (then git merge --abort)"
        - "git log --merges                    # History of merges"
      use_for: "Reviewing PRs, understanding merge impact"
    
    cherry_pick_planning:
      description: "Surgical extraction of specific commits"
      commands:
        - "git log --oneline <branch>          # Find commits to pick"
        - "git show <commit>                   # Inspect before picking"
        - "git cherry-pick --no-commit <hash>  # Preview (then reset)"
        - "git cherry -v <upstream> <branch>   # What's not yet upstream?"
      use_for: "Backporting fixes, selective feature extraction"
    
    rebase_planning:
      description: "Plan history rewriting"
      commands:
        - "git log --oneline main..HEAD        # Commits to rebase"
        - "git rebase --onto <new> <old> <br>  # Transplant commits"
      use_for: "Cleaning history before merge"

  # PR ARCHAEOLOGY ‚Äî Understanding pull requests
  pr_archaeology:
    description: "Trace the intent through PRs"
    commands:
      - "gh pr list --state merged             # Merged PRs"
      - "gh pr view <num>                      # PR details"
      - "gh pr diff <num>                      # What the PR changed"
      - "gh pr checks <num>                    # CI results"
      - "git log --merges --grep='#123'        # Find merge commit for PR"
    use_for: "Understanding why code exists, tracing decisions"

  # INTEGRATION WITH CURSOR-MIRROR
  cursor_mirror_git_link:
    description: "Connect git commits to cursor-mirror sessions"
    workflow:
      - "1. Find commit: git log --oneline"
      - "2. Get timestamp: git show -s --format=%ci <commit>"
      - "3. Find session: cursor-mirror tail --limit 100"
      - "4. Match by time: session active during commit"
      - "5. Get thinking: cursor-mirror thinking <composer>"
    use_for: "Full provenance: commit ‚Üí session ‚Üí thinking ‚Üí user request"

# SHELL INTEGRATION ‚Äî Data Processing Pipeline

shell_patterns:
  counting:
    - "wc -l file                    # Line count"
    - "wc -c file                    # Byte count"
    - "grep -c 'pattern' file        # Match count"
  
  frequency_analysis:
    - "sort | uniq -c | sort -rn     # Histogram"
    - "cut -d' ' -f1 | sort | uniq -c"
  
  text_extraction:
    - "grep 'pattern' file           # Filter lines"
    - "grep -o 'pattern' file        # Extract matches only"
    - "sed 's/old/new/' file         # Transform"
    - "awk '{print $1, $3}'          # Select columns"
  
  aggregation:
    - "awk '{sum+=$1} END{print sum}'"
    - "awk 'NR==1{min=max=$1} {if($1<min)min=$1; if($1>max)max=$1} END{print min,max}'"
  
  python_inline:
    - "python3 -c 'import json,sys; data=json.load(sys.stdin); ...'"
    - "python3 -c 'from collections import Counter; ...'"

# AUTOMATION

automation:
  pre_commit_hook:
    description: "Optionally validate commit messages"
    checks:
      - "Title exists and is <50 chars"
      - "Body provides context (not just 'updated file')"
      - "Changes are listed"
    
  post_commit_hook:
    description: "Optionally link to cursor-mirror after commit"
    actions:
      - "Extract commit hash"
      - "Find recent cursor-mirror events"
      - "Store link in .moollm/skills/thoughtful-commitment/commit-links.yml"
