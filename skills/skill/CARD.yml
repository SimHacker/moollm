# CARD.yml ‚Äî The Skill Forge
#
# SNIFFABLE INTERFACE ‚Äî see SKILL.md for full documentation
# "A skill is documentation that learned to do things."
#
# For CARD architecture (what goes where), see skills/card/SKILL.md

card:
  id: skill
  name: "The Skill Forge"
  type: [skill, meta, creation, prototype]
  emoji: üõ†Ô∏è
  tier: 1
  rarity: mythic
  tagline: "A skill is documentation that learned to do things."
  
  description: |
    The meta-skill for creating, understanding, and debugging skills.
    Every skill you encounter was forged here.
    
    MOOLLM's eight extensions (see designs/eval/EVAL-INCARNATE-FRAMEWORK.md):
    1. **Instantiation**: Skills as prototypes that create instances
    2. **Three-Tier Persistence**: Platform ‚Üí Narrative ‚Üí State
    3. **K-lines**: Names as semantic activation vectors (Minsky)
    4. **Empathic Templates**: Smart generation, not string substitution
    5. **Speed of Light**: Many turns in one call (33-turn Fluxx proof)
    6. **CARD.yml**: Machine-readable interface with advertisements
    7. **Ethical Framing**: Room-based inheritance of performance context
    8. **Ambient Skills**: Always-on behavioral shaping via AMBIENT advertisements

# FILES INDEX ‚Äî Activate together for full context

files:
  docs:
    - SKILL.md                         # Full protocol documentation  
    - README.md                        # Human landing page
  templates:                           # USE THESE when creating new skills!
    - SKILL.md.tmpl                    # Template for new SKILL.md
    - README.md.tmpl                   # Template for new README.md
    - ../card/CARD.yml.tmpl            # Template for new CARD.yml (in card skill)
  protocols:
    - skill-instantiation-protocol.md  # How instantiation works
    - delegation-object-protocol.md    # Self-style delegation
  see_also:
    - ../card/SKILL.md                 # Card architecture (what goes where)
    - ../card/CARD.yml                 # The card skill itself

# K-LINES

k-lines:
  activates:
    - SKILL
    - SKILL-FORGE
    - PROTOTYPE
    - INSTANTIATION
    - EMPATHIC-TEMPLATE
  related:
    - { ref: card, relation: "cards are skill instances" }
    - { ref: prototype, relation: "Self-style inheritance" }
    - { ref: play-learn-lift, relation: "skill evolution methodology" }

# INVOKE WHEN

invoke_when:
  - "Create a new skill"
  - "Debug why a skill isn't working"
  - "Upgrade skill capabilities"
  - "Lift local pattern to central skill"
  - "Compose multiple skills"

# ADVERTISEMENTS (PRIMARY)

advertisements:
  CREATE-SKILL:
    score: 90
    condition: "Need to make a new reusable capability"
    
  INSTANTIATE-SKILL:
    score: 85
    condition: "Create instance from skill prototype"
    
  DEBUG-SKILL:
    score: 80
    condition: "Skill is broken or incomplete"
    
  LIFT-PATTERN:
    score: 75
    condition: "Have a local pattern worth generalizing"
    
  COMPOSE-SKILLS:
    score: 70
    condition: "Need to combine multiple skills"

# METHODS ‚Äî signatures only

methods:
  CREATE:      { signature: "CREATE [name] (tier) (prototypes)" }
  INSTANTIATE: { signature: "INSTANTIATE [skill] AT [location]" }
  DEBUG:       { signature: "DEBUG [skill-path]" }
  UPGRADE:     { signature: "UPGRADE [skill] TO [tier]" }
  LIFT:        { signature: "LIFT [pattern] AS [name]" }
  COMPOSE:     { signature: "COMPOSE [skills] AS [name]" }

# MOOLLM'S eight extensions to Anthropic's skill model
# (see designs/eval/EVAL-INCARNATE-FRAMEWORK.md)

innovations:
  1-instantiation: "Skills as prototypes that create instances"
  2-three-tier: "Platform ‚Üí Narrative ‚Üí State persistence"
  3-k-lines: "Names activate entire knowledge contexts (Minsky)"
  4-empathic-templates: "Smart semantic expansion, not string substitution"
  5-speed-of-light: "Many agents, many turns, one LLM call"
  6-card-yml: "Machine-readable interface with advertisements"
  7-ethical-framing: "Room-based inheritance of performance context"
  8-ambient-skills: "Always-on skills via AMBIENT advertisements"

# DIRECTORIES AS INTERESTS
# A fundamental organizing principle: ls output IS the semantic index

directories_as_interests:
  concept: |
    Directory listings are VIRTUAL INTERESTS for the LLM.
    Well-written filenames are LLM-recognizable K-lines.
    The `ls` output IS the index. Directories are expandable outlines.
    
  big_endian_naming: |
    Most significant component FIRST:
    ‚úì 2026-01-24-description.yml   (date groups by time)
    ‚úì RUN-001-name.yml             (number groups by sequence)
    ‚úì CARD.yml                     (type identifies purpose)
    
  why_it_matters: |
    The LLM lists directories. It searches. It navigates.
    Good naming makes filenames themselves semantic signals.
    The structure guides the LLM through the content.
    
  examples:
    good:
      - "examples/2026-01-24-mafia-tribute-relationship.yml"
      - "runs/RUN-001-amsterdam-fluxx.yml"
      - "skills/no-ai-gloss/CARD.yml"
    avoid:
      - "examples/example1.yml"           # Not semantic
      - "runs/fluxx-amsterdam-001.yml"    # Identifier buried
      - "skills/gloss.yml"                # No structure signal

# HIERARCHICAL SKILLS ‚Äî Skills can contain instances and runs

hierarchical_skills:
  concept: |
    Skills can exist in hierarchies ‚Äî nested directories with instances:
    
    skills/experiment/              # The skill definition
    ‚îú‚îÄ‚îÄ CARD.yml
    ‚îú‚îÄ‚îÄ SKILL.md
    ‚îú‚îÄ‚îÄ templates/
    ‚îÇ   ‚îî‚îÄ‚îÄ RUN.yml.tmpl           # Template for new runs
    ‚îî‚îÄ‚îÄ experiments/
        ‚îî‚îÄ‚îÄ fluxx-chaos/           # An experiment INSTANCE
            ‚îú‚îÄ‚îÄ EXPERIMENT.yml
            ‚îî‚îÄ‚îÄ runs/
                ‚îî‚îÄ‚îÄ amsterdam-flux/ # A run INSTANCE
                    ‚îú‚îÄ‚îÄ RUN.yml
                    ‚îú‚îÄ‚îÄ RUN-000.yml # Iteration 0
                    ‚îú‚îÄ‚îÄ RUN-001.yml # Iteration 1
                    ‚îî‚îÄ‚îÄ ...
    
  instance_tree: |
    The directory hierarchy IS the instance tree:
    - skills/experiment/        ‚Üí The skill (prototype)
    - experiments/fluxx-chaos/  ‚Üí An experiment instance
    - runs/amsterdam-flux/      ‚Üí A run instance within that experiment
    - RUN-000.yml               ‚Üí An iteration within that run
    
    Each level inherits from above. Directories scope instances.
    
  naming_convention: |
    Templates: RUN.yml.tmpl, EXPERIMENT.yml.tmpl
    Instances: RUN-000.yml, RUN-001.yml (big-endian numbered)
    
    The number groups iterations. The name identifies the run.
    
  path_as_context: |
    The path IS the activation context:
    
    skills/experiment/experiments/fluxx-chaos/runs/amsterdam-flux/RUN-003.yml
    
    The LLM reading this path knows:
    - It's in the experiment skill
    - Specifically the fluxx-chaos experiment
    - Specifically the amsterdam-flux run
    - Specifically iteration 3
    
    No metadata needed. The path IS the metadata.

# AMBIENT SKILLS ‚Äî Always-on behavioral shaping
# See SKILL.md ¬ß Ambient Skills for full documentation

ambient_skills:
  concept: |
    Some skills should be "in the air" ‚Äî always available, always shaping
    output without explicit invocation. Like air filters that clean
    continuously, not just when you smell smoke.
    
  declaration: |
    Skills declare ambient behavior using the AMBIENT advertisement type.
    This fits naturally with the existing advertisement system ‚Äî the skill
    is literally advertising "I want to be in context."
    
  examples:
    - no-ai-slop      # Syntactic hygiene (always)
    - no-ai-gloss     # Semantic hygiene (always)
    - postel          # Robustness (always)
    - yaml-jazz       # When writing YAML
    - representation-ethics  # When simulating real people

# AMBIENT ADVERTISEMENT SCHEMA

ambient_advertisement_schema:
  description: "How skills declare they want to be ambient"
  
  example: |
    # In CARD.yml advertisements section:
    advertisements:
      AMBIENT:
        score: 100              # Priority (0-100, higher = more likely kept)
        condition: always       # Or: "when writing YAML", "when discussing power"
        scope: session          # Or: card-only, room, conversation
        resolution: summary     # Or: full, sniff, card-only
        
  fields:
    score:
      type: integer
      range: [0, 100]
      description: "Priority for context budget allocation (higher = keep longer)"
    condition:
      type: string
      options: [always, when-condition-met]
      description: "'always' or a condition string the orchestrator evaluates"
    scope:
      type: string
      options: [session, conversation, room, card-only]
      description: "How long the ambient effect persists"
    resolution:
      type: string
      options: [full, summary, sniff, card-only]
      description: "How much of the skill to keep in context"
      
  orchestrator_behavior: |
    The orchestrator:
    1. Collects all AMBIENT advertisements from loaded skills
    2. Evaluates conditions against current context
    3. Sorts by score
    4. Loads skills at their declared resolution until context budget exhausted
    5. Refreshes on context change (new room, new topic, etc.)
    
    REALITY: We don't control Cursor/Claude Code orchestrators.
    PRAGMATIC: Manual hot list + CARD.yml declaration.
    FUTURE: MOOCO orchestrator enables full AMBIENT.yml layered wake-up.
    
  design_decision: |
    Why AMBIENT in CARD.yml, not separate AMBIENT.yml:
    - Requires orchestrator we don't control
    - CARD.yml already sniffable
    - "Throw down the gauntlet": want ambient? Declare AMBIENT advertisement.
    - Skill says how to handle activation; we manage via hot.yml

# STATE

state:
  fields: [current-skill, prototype-chain, instantiation-context]

# TOOLS

tools:
  required: [read_file, write_file]
  optional: [list_dir, grep]

# DOCUMENTATION POINTERS

documentation:
  SKILL.md:
    - "¬ß Skill Creation Protocol"
    - "¬ß Instantiation (prototype ‚Üí instance)"
    - "¬ß Empathic Templates"
    - "¬ß Three-Tier Persistence"
    - "¬ß Speed of Light Simulation"
  templates:
    - "SKILL.md.tmpl ‚Äî use for new SKILL.md files"
    - "README.md.tmpl ‚Äî use for new README.md files"
    - "../card/CARD.yml.tmpl ‚Äî use for new CARD.yml files"
  see_also:
    - "../card/SKILL.md ¬ß Card Architecture"
    - "../card/CARD.yml ¬ß Card skill interface"

# LINEAGE

lineage:
  - { name: "Self language", source: "David Ungar & Randy Smith", year: 1987 }
  - { name: "Society of Mind", source: "Marvin Minsky" }
  - { name: "Constructionism", source: "Seymour Papert" }
