# CARD.yml ‚Äî YAML Jazz
#
# Comments as semantic data ‚Äî structure for LLMs, not just machines.
# "The comments ARE the data."

card:
  id: yaml-jazz
  name: "YAML Jazz"
  type: [skill, meta, design]
  emoji: üé∑
  rarity: uncommon
  
  description: |
    Semantic YAML where comments are first-class data.
    The LLM reads and interprets comments. Structure is
    for humans AND machines AND LLMs.

tools:
  required: []
tier: 0

methods:
  IMPROVISE:
    description: "Create YAML Jazz structure"
    parameters: { content: "What to structure" }
    output: chat (YAML)
    invoked-by: [player]
    
  INTERPRET:
    description: "Read YAML Jazz semantically"
    parameters: { yaml: "Content to interpret" }
    output: chat (understanding)
    invoked-by: [any]

state: {}

principles:
  comments-matter: "# Comments are semantic data for the LLM"
  structure-guides: "Hierarchy implies relationship"
  flexibility: "Accept variations, emit consistency (Postel)"
  human-readable: "Optimize for understanding, not parsing"
  entropy-preservation: "YAML preserves generation entropy; JSON causes collapse"
  directories-as-interests: "Directory listings ARE the interest index"
  big-endian-naming: "Most significant first: 2026-01-24-description.yml"

# YAML JAZZ vs JAVASCRIPT/JSON
# Why MOOLLM yaml jazz beads are semantically richer than what JS can express

yaml_vs_javascript:
  
  thesis: |
    MOOLLM beads are YAML Jazz ‚Äî MUCH and MEANINGFULLY semantically richer
    than what you can express in JavaScript objects or JSON.
    
    JavaScript gives you data.
    YAML Jazz gives you DATA + MEANING + CONTEXT + REASONING.
  
  what_javascript_cannot_express:
    
    comments_as_data: |
      JavaScript:
        { status: "pending", priority: "high" }
        // Why is this high priority? WHO KNOWS
        
      YAML Jazz:
        status: pending
        priority: high
        # HIGH because user explicitly asked for this feature
        # and it blocks three other tasks. See: moollm-015
        # Inner voice: "This is the bottleneck."
        
      THE COMMENT IS THE REASONING. The LLM reads it.
      
    inline_context: |
      JavaScript:
        { name: "no-ai-slop", type: "skill" }
        
      YAML Jazz:
        name: no-ai-slop
        type: skill
        # AMBIENT SKILL ‚Äî always-on air filter for output
        # Catches: verbosity, hallucination, yes-man behavior
        # Why it matters: Trust requires truth
        
      The structure is self-documenting. The context travels with the data.
      
    multiline_prose: |
      JavaScript:
        { description: "A skill that prevents AI slop including verbosity..." }
        // UGLY. No line breaks. No formatting. Just a blob.
        
      YAML Jazz:
        description: |
          AI slop is everything that makes AI annoying:
          
          - **Verbosity**: 500 words when 50 would do
          - **Hallucination**: Making up facts, links, citations
          - **Yes-man behavior**: Agreeing with everything
          
          The goal is not to "sound human" ‚Äî it's to not be annoying.
          
      YAML's | preserves formatting, line breaks, markdown.
      The prose breathes. The structure teaches.
      
    nested_reasoning: |
      JavaScript:
        { 
          task: "fix bug",
          notes: "check the parser first then the lexer"
        }
        
      YAML Jazz:
        task: "fix bug"
        
        reasoning:
          hypothesis: "Parser is mishandling edge case"
          # I think this because the error message mentions unexpected token
          # but the input looks valid. Classic parser vs lexer confusion.
          
          investigation_order:
            - parser.ts      # Most likely culprit
            - lexer.ts       # If parser is clean
            - tokenizer.ts   # Last resort
            # This order based on error message proximity
            
          inner_voice: |
            "I've seen this before. Usually it's the parser
            trying to be too clever. Check the lookahead first."
            
      THE REASONING IS PRESERVED. The future-self (or LLM) knows WHY.
      
    skill_embedding: |
      JavaScript:
        { bead_id: "moollm-030", skills: ["yaml-jazz", "bead-bracelet"] }
        // Just references. No context. No activation.
        
      YAML Jazz:
        bead:
          id: moollm-030
          
          # SKILLS THAT ACTIVATE FOR THIS BEAD
          skills:
            - yaml-jazz       # Because beads ARE yaml jazz
            - bead-bracelet   # Because this chains with others
            - no-ai-slop      # Ambient hygiene
            
          # WHY THIS MATTERS
          # Beads are the universal message capsule.
          # They flow through pneumatic tubes (postal system).
          # They organize into bracelets, curtains, borgs.
          # YAML Jazz makes them self-describing.
          
      The skill embedding carries its own explanation.

  what_yaml_jazz_enables:
    
    llm_readable_reasoning: |
      LLMs don't just parse YAML Jazz ‚Äî they UNDERSTAND it.
      The comments become part of the semantic context.
      The structure becomes part of the meaning.
      
    git_friendly_diffs: |
      YAML diffs show semantic changes:
      
      - priority: medium
      + priority: high
      + # ESCALATED: User flagged as blocking
      
      JSON diffs show... characters moved.
      
    human_llm_machine_readable: |
      YAML Jazz serves THREE audiences:
      1. Humans ‚Äî read the comments, understand intent
      2. LLMs ‚Äî read everything, understand context
      3. Machines ‚Äî parse the structure, execute logic
      
    extensibility_without_breaking: |
      Add a field? Add a comment? Add a section?
      Nothing breaks. Postel's law: accept liberally.
      
      JavaScript schemas are brittle.
      YAML Jazz is robust.

  the_moollm_bead_advantage: |
    A MOOLLM bead isn't just a task object.
    
    It's a task + reasoning + context + history + relationships
    + inner voice + semantic tags + activation hints + everything
    an LLM needs to understand not just WHAT but WHY and HOW
    and WHAT ELSE and WHAT NEXT.
    
    JavaScript can't express this.
    JSON can't preserve this.
    YAML Jazz IS this.

  empirical_evidence: |
    Sunil Kumar (Groundlight AI, 2025):
    "Switching from JSON to YAML for tool calling massively improved
    generation entropy stability during GRPO training."
    
    JSON's strict syntax constrains the model's ability to search and reason.
    YAML gives the model room to breathe, to comment, to explain.
    
    https://x.com/__sunil_kumar_/status/1916926342882594948

# DIRECTORIES AS INTERESTS
# A fundamental organizing principle for LLM navigation

directories_as_interests:
  concept: |
    When an LLM lists a directory, the filenames serve as 
    VIRTUAL INTERESTS ‚Äî semantic signals about what's available.
    
    Well-written filenames are LLM-recognizable K-lines.
    The `ls` output IS the index. No separate index file needed.
    
  big_endian_naming: |
    Most significant component FIRST:
    
    ‚úì 2026-01-24-mafia-tribute-relationship.yml   (date first)
    ‚úó mafia-tribute-relationship-2026-01-24.yml   (date buried)
    
    ‚úì RUN-001-amsterdam-fluxx.yml                 (run number first)
    ‚úó amsterdam-fluxx-run-001.yml                 (identifier buried)
    
    Why: Sorting groups by significance. Date-first groups by time.
    Number-first groups by sequence. The LLM sees the pattern.
    
  directories_as_outlines: |
    A directory structure IS an outline the LLM can navigate:
    
    skills/
    ‚îú‚îÄ‚îÄ no-ai-gloss/          ‚Üê "Semantic hygiene"
    ‚îÇ   ‚îú‚îÄ‚îÄ CARD.yml          ‚Üê Quick interface
    ‚îÇ   ‚îú‚îÄ‚îÄ SKILL.md          ‚Üê Deep protocol
    ‚îÇ   ‚îî‚îÄ‚îÄ examples/         ‚Üê Learning artifacts
    ‚îÇ       ‚îú‚îÄ‚îÄ INDEX.yml
    ‚îÇ       ‚îî‚îÄ‚îÄ 2026-01-24-mafia-tribute-*.yml
    ‚îî‚îÄ‚îÄ no-ai-slop/           ‚Üê "Syntactic hygiene"
        ‚îî‚îÄ‚îÄ ...
    
    The LLM reads structure. Each level reveals more detail.
    Directories are expandable outlines.
    
  filenames_as_klines: |
    A good filename activates semantic understanding:
    
    "2026-01-24-euphemism-laundering-mafia-tribute.yml"
    
    The LLM sees: date, concept, metaphor ‚Äî before opening the file.
    This is a K-line: the name activates related knowledge.
    
  seamless_embedding: |
    YAML Jazz structures can embed skill instances:
    
    room:
      objects:
        - !include objects/lamp.yml
        - !include objects/desk.yml
      characters:
        - !include ../characters/palm.yml
        
    Directories become modular components.
    The filesystem IS the object hierarchy.

# Empirical validation: Sunil Kumar (Groundlight AI, 2025) found that
# switching from JSON to YAML for tool calling "massively improved
# generation entropy stability" during GRPO training. JSON's strict
# syntax constrains the model's ability to search and reason.
# https://x.com/__sunil_kumar_/status/1916926342882594948

example: |
  # A character's inner conflict
  # The LLM reads this and understands the dramatic tension
  conflict:
    surface: "Wants to be brave"
    hidden: "Terrified of failure"
    # The tension between these drives the story

advertisements:
  SEMANTIC-YAML:
    score: 90
    condition: "Need YAML that LLMs understand deeply"
  DESIGN-STRUCTURE:
    score: 85
    condition: "Creating human+machine+LLM readable format"

see-also: [skills/postel, skills/protocol]
