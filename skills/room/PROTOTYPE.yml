# Room Skill Prototype
# Directories as activation contexts

skill:
  name: "room"
  tier: 1  # File-only
  protocol: "ROOM-AS-FUNCTION"
  
  description: |
    Rooms are directories that serve as activation contexts.
    Enter = call function, push context.
    Exit = return, pop context.
    Cards in play = active task instances.
    
  motto: "Entering is calling. Exiting is returning."

inputs:
  name:
    type: string
    required: true
    description: "Name of the room"
    
  purpose:
    type: string
    required: true
    description: "What this room is for"
    
  parent:
    type: path
    default: ".agent/rooms/"
    description: "Where to create the room"

outputs:
  room_path: "{parent}/{name}/"
  room_file: "ROOM.yml"
  readme_file: "README.md"

# ROOM SCHEMA

room_schema:
  required:
    - name
    - purpose
    
  optional:
    - context
    - cards_in_play
    - working_set
    - exits          # Doors to other rooms
    - nested         # Rooms inside this room
    - outside        # Parent room (auto-link)
    - atmosphere
    - portable       # Can this room be picked up?
    - location       # Where is this room currently?

# CONNECTIONS & NAVIGATION

connections:
  description: |
    Rooms have doors/links to other rooms.
    Navigation is traversing the connection graph.
    
  exit_schema:
    name: "Door/link name (e.g., 'north', 'to-lobby', 'deeper')"
    target: "path/to/destination/room"
    description: "What you see when you look at this exit"
    locked: "boolean - requires key/condition?"
    
  special_exits:
    outside:
      description: "Always exists. Link to parent room."
      auto_generated: true
      
    nested:
      description: "List of rooms contained inside this room"
      auto_generated: "From subdirectories with ROOM.yml"
      
  example: |
    exits:
      - name: "lobby"
        target: "../lobby/"
        description: "Back to the main entrance"
      - name: "deeper"
        target: "./archives/"
        description: "Into the dusty archives"
    outside: "../"  # Auto-link to parent
    nested:
      - "./archives/"
      - "./vault/"

# NESTED ROOMS (Rooms in Rooms)

nesting:
  description: |
    Rooms can contain other rooms.
    Subdirectories with ROOM.yml are nested rooms.
    
  structure: |
    palace/
      ROOM.yml           # The palace
      treasury/
        ROOM.yml         # Room inside the palace
        vault/
          ROOM.yml       # Room inside the treasury
          
  auto_linking: |
    When you enter a room:
    - `outside` automatically points to parent
    - `nested` automatically lists child rooms
    - No manual linking required for hierarchy

# VIRTUAL SUB-ROOMS (Zones Without Directories)

virtual_rooms:
  description: |
    Not every sub-location needs its own directory!
    
    Virtual sub-rooms (zones) are defined INLINE in the parent room file.
    Characters reference them by path, but no physical dir exists.
    Files stay FLAT. Paths drill down to VIRTUAL locations.
    
  why:
    - "Keep files flat and simple"
    - "Avoid directory sprawl for logical divisions"
    - "Still get addressable sub-locations"
    - "Objects declare their zone via location field"
    
  pattern: |
    # Physical structure (flat):
    pub/
      ROOM.yml           # The pub
      cat-cave.yml       # Defines virtual zones inline
      cat-terpie.yml     # home: pub/, location: pub/cat-cave/nap-zone
      cat-stroopwafel.yml
      
    # NO subdirectories for cat-cave zones!
    # Zones are defined IN cat-cave.yml:
    
    zones:
      - id: vestibule
        path: pub/cat-cave/vestibule
      - id: nap-zone
        path: pub/cat-cave/nap-zone
      - id: depths
        path: pub/cat-cave/depths
        
  how_objects_use_it: |
    # In cat-terpie.yml:
    cat:
      home: pub/                       # File lives here
      location: pub/cat-cave/nap-zone  # Virtual path (no dir exists)
      
    The path "pub/cat-cave/nap-zone" resolves to:
    1. pub/ → physical directory
    2. cat-cave → object file defining zones
    3. nap-zone → zone id defined in that file
    
  common_pattern: |
    Room with ROOM.yml + prefixed characters:
    
    pub/
      ROOM.yml               # The room
      staff-marieke.yml      # Staff prefix
      staff-jan.yml
      cat-terpie.yml         # Cat prefix
      cat-stroopwafel.yml
      kitten-myrcene.yml     # Kitten prefix
      kitten-limonene.yml
      kitten-linalool.yml
      menu.yml               # Objects
      jukebox.yml
      
    Prefixes organize without subdirectories.
    Easy to see all cats: cat-*.yml
    Easy to see all staff: staff-*.yml
    
  when_to_use_subdirs: |
    If a group has MANY files or needs isolation:
    
    pub/
      ROOM.yml
      bartender.yml
      cat-cave/              # Real subdir — cats live here
        ROOM.yml             # Zone definitions
        terpie.yml           # No prefix needed in subdir
        stroopwafel.yml
        kitten-myrcene.yml
        kitten-limonene.yml
        
    The cat-cave/ subdir keeps pub/ uncluttered.
    Zones WITHIN cat-cave (nap-zone, depths) stay virtual.
    
  choosing:
    prefixes: |
      - Few files (5-10)
      - Quick visual grouping
      - Single room context
      
    subdirs: |
      - Many files (10+)
      - Need isolation
      - Sub-room with own identity
    
  example_zone_definition: |
    # In cat-cave.yml:
    zones:
      - id: vestibule
        path: pub/cat-cave/vestibule
        description: "Near the entrance"
        
      - id: nap-zone  
        path: pub/cat-cave/nap-zone
        description: "Prime sleeping territory"
        properties:
          temperature: warm
          light: none
          
      - id: depths
        path: pub/cat-cave/depths
        description: "Further than mapped"
        mystery: true
        
  querying: |
    To find who's in a virtual zone:
    
    # Find all entities where location starts with pub/cat-cave/nap-zone
    # This is a path prefix match, not a directory listing
    
  vs_physical_subdirs: |
    Use PHYSICAL subdirs when:
    - Zone has MANY objects (5+ files)
    - Would clutter parent directory
    - Zone is complex enough to warrant isolation
    - Zone needs its own ROOM.yml
    
    Use VIRTUAL zones when:
    - Just dividing a space logically
    - Objects are few (1-4 files)
    - Sub-zones within an already-isolated area
    - Simplicity is preferred
    
    HYBRID example (cat-cave):
    - pub/cat-cave/ is a PHYSICAL subdir (10+ cats would clutter pub/)
    - cat-cave/nap-zone is a VIRTUAL zone (no files specific to it)
    - cat-cave/depths is a VIRTUAL zone (just a location reference)

# HYPERCARD STRUCTURE

hypercard_analogy:
  description: |
    Rooms map naturally to HyperCard's hierarchy:
    - Stack = top-level room
    - Background = shared context (inherited by cards)
    - Card = individual room/view
    - Object = button, field, card in play
    
  directory_as_action: |
    Sub-directory NAMES are action/direction names:
    
    room/
      ROOM.yml           # The room itself
      north/             # GO NORTH = enter this sub-room
        ROOM.yml
      examine-chest/     # EXAMINE CHEST = enter OR launch task
        ROOM.yml         # If has ROOM.yml → sub-room
      open-door/         # OPEN DOOR = play card if no ROOM.yml
        CARD.yml         # Task button → plays card in parent room
        
  leaf_as_button: |
    Directories without ROOM.yml are "buttons" that launch tasks or play cards or cast spells or delegate messages:
    
    room/
      debug/             # Has ROOM.yml → sub-room (enter it)
        ROOM.yml
      run-tests/         # No ROOM.yml → button (launch task)
        CARD.yml         # Card to play in parent room
        parameters.yml   # Task parameters
        
  message_delegation: |
    Messages flow LEAF → ROOT (like HyperCard):
    
    vault/               # Leaf room
      ↓ (not handled)
    treasury/            # Parent
      ↓ (not handled)  
    palace/              # Grandparent
      ↓ (not handled)
    root/                # Root room
      ↓ (not handled)
    system               # System handler
    
    Example: "SEARCH" in vault
    1. vault doesn't handle SEARCH → delegate up
    2. treasury has search capability → handles it
    
  inheritance: |
    Like HyperCard backgrounds, parent room context is inherited:
    - Cards in play in parent are "visible" from child
    - Working set cascades down
    - Atmosphere/mood inherits unless overridden

# RETURN STACK / CONTINUATIONS

return_stack:
  description: |
    List of rooms to return to — like continuation passing.
    Browser history. Call stack. Breadcrumbs.
    
  kept_in_pocket: |
    The return stack travels WITH YOU:
    - Portable across sessions
    - Can save and restore navigation history
    - Share your journey with others
    
  schema:
    return_stack:
      - path: "projects/moollm/"
        entered: "2025-01-15T10:00:00Z"
        context_snapshot: "working on README"
      - path: "projects/moollm/skills/"
        entered: "2025-01-15T10:05:00Z"
        context_snapshot: "exploring skills"
      - path: "projects/moollm/skills/room/"
        entered: "2025-01-15T10:10:00Z"
        context_snapshot: "current location"
        
  operations:
    back:
      description: "Pop and return to previous room"
      like: "Browser back button"
      
    forward:
      description: "Go forward in history (if backed up)"
      like: "Browser forward button"
      
    history:
      description: "Show navigation history"
      like: "Browser history view"
      
    bookmark:
      description: "Save current location for quick return"
      like: "Browser bookmark"
      
    goto_bookmark:
      description: "Jump to bookmarked location"
      
  continuation_passing: |
    The return stack IS a continuation:
    - First-class: can save, share, serialize
    - Resumable: pick up where you left off
    - Forkable: branch into multiple paths
    
    Like Scheme call/cc:
    - Capture current continuation (where to return)
    - Pass it around, invoke it later
    - Multiple returns possible
    
  browser_analogy: |
    return_stack  ←→  browser history
    bookmark      ←→  browser bookmark
    back          ←→  back button
    forward       ←→  forward button
    new_tab       ←→  fork continuation
    
  multiple_stacks: |
    Can have MULTIPLE return stacks (like browser tabs):
    
    stacks:
      main:        [lobby → project → code]
      research:    [library → papers → arxiv]
      debugging:   [logs → stack-trace → source]
      
    Switch between stacks = switch cognitive contexts

# PORTABLE ROOMS (Vehicles & Pockets)

portable_rooms:
  description: |
    Some rooms are PORTABLE — you can pick them up and carry them.
    Like LambdaMOO vehicles, TARDIS, bags of holding.
    
  operations:
    embark:
      description: "Enter a portable room (get in the vehicle)"
      effect: "You're now inside the portable room"
      
    disembark:
      description: "Exit to wherever the portable room is located"
      effect: "You're now in the room containing the portable"
      
    pick_up:
      description: "Put the portable room in your pocket/inventory"
      effect: "Room becomes an item you carry"
      requires: "Room must be empty of other characters"
      
    drop:
      description: "Place the portable room in current location"
      effect: "Room becomes accessible in this location"
      
    drive:
      description: "Move the portable room to a new location"
      effect: "Everyone inside moves with it"
      
  schema:
    portable: true
    location: "path/to/current/container"  # Where is this room?
    capacity: "how many can be inside"
    embarked: ["list", "of", "occupants"]
    
  examples:
    tardis:
      description: "Bigger on the inside. Can go anywhere."
      portable: true
      
    bag_of_holding:
      description: "Pocket dimension for storage"
      portable: true
      capacity: 100
      
    research_tent:
      description: "Set up camp anywhere"
      portable: true
      working_set: ["research notes", "tools"]
      
  use_cases:
    - "Carry your workspace between projects"
    - "Deploy a debugging environment anywhere"
    - "Share a room by handing it to someone"
    - "Archive a room by putting it in storage"

# CARD IN PLAY SCHEMA

card_instance_schema:
  required:
    - instance      # Unique instance ID
    - card          # Card template name
    - goal          # What this instance is working toward
    
  optional:
    - parameters    # Input parameters
    - state         # Current working state
    - subgoals      # Decomposed goals
    - return_value  # Filled when complete

# OPERATIONS

operations:
  enter_room:
    description: "Enter a room, push its context"
    inputs: [path]
    effects:
      - "Load ROOM.yml"
      - "Add working_set to context"
      - "Room becomes current"
      
  exit_room:
    description: "Exit room, pop context"
    effects:
      - "Save state changes"
      - "Pop from context"
      - "Return to parent"
      
  activate_card:
    description: "Put a card in play in current room"
    inputs: [card, parameters, goal]
    effects:
      - "Clone card template"
      - "Add to cards_in_play"
      - "Card begins work"
    note: "Same card can be active in multiple rooms simultaneously"
      
  complete_card:
    description: "Mark card instance as complete"
    inputs: [instance, return_value]
    effects:
      - "Write return_value"
      - "Mark complete"
      - "Optionally remove"
      
  look:
    description: "Describe current room"
    outputs: ["Room description", "Cards in play", "Exits"]
    
  send_message:
    description: "Send data to another card instance"
    inputs: [from_instance, to_instance, content]
    effects:
      - "Append to target's messages_received"
      - "Target can incorporate or respond"
    note: "Cross-room communication between actors"

# MULTI-PRESENCE & DATA FLOW

multi_presence:
  description: "Cards can be active in multiple rooms simultaneously"
  
  patterns:
    parallel_exploration:
      description: "Same expertise applied to different problems"
      example: "Papert in research/, writing/, and debugging/"
      
    cross_pollination:
      description: "Insights flow between instances"
      mechanism: "message_to / messages_received"
      
    distributed_work:
      description: "One persona, many concurrent tasks"
      
    consensus:
      description: "Multiple instances synthesize into decision"

message_schema:
  message_to:
    target: "path to recipient instance"
    content: "any structured data"
    
  messages_received:
    type: array
    items:
      from: "path to sender"
      content: "structured data"
      timestamp: "when received"
      incorporated: "boolean - has this been processed?"

# ROOM TYPES

room_types:
  session:
    description: "Temporary work context"
    lifetime: "Task duration"
    examples: ["debug-session/", "feature-work/"]
    
  project:
    description: "Persistent project home"
    lifetime: "Long-term"
    examples: ["moollm/", "my-app/"]
    
  concept:
    description: "Knowledge location in memory palace"
    lifetime: "Permanent"
    examples: ["yaml-jazz/", "postel/"]
    
  character:
    description: "Persona's living space"
    lifetime: "Permanent"
    examples: ["gardener/", "archivist/"]
    
  portable:
    description: "Carryable room — TARDIS, bag of holding"
    lifetime: "Until discarded"
    portable: true
    examples: ["research-tent/", "debugging-kit/", "workshop/"]
    
  vehicle:
    description: "Room you drive around"
    lifetime: "Until parked"
    portable: true
    examples: ["mobile-lab/", "expedition/"]

# COMMANDS

commands:
  # Basic navigation
  ROOM:
    syntax: "ROOM [name]"
    action: "Create or enter room"
    
  LOOK:
    syntax: "LOOK"
    action: "Describe current room, exits, nested rooms, cards"
    
  GO:
    syntax: "GO [exit-name]"
    action: "Take an exit to another room"
    
  EXIT:
    syntax: "EXIT"
    action: "Go to 'outside' (parent room)"
    
  ENTER:
    syntax: "ENTER [nested-room]"
    action: "Enter a nested room"
    
  # Card operations
  ACTIVATE:
    syntax: "ACTIVATE [card] [goal]"
    action: "Put card in play"
    
  COMPLETE:
    syntax: "COMPLETE [instance]"
    action: "Mark card done"
    
  # Portable room operations
  EMBARK:
    syntax: "EMBARK [portable-room]"
    action: "Enter a portable room"
    
  DISEMBARK:
    syntax: "DISEMBARK"
    action: "Exit portable to its container"
    
  PICKUP:
    syntax: "PICKUP [portable-room]"
    action: "Put room in pocket/inventory"
    
  DROP:
    syntax: "DROP [portable-room]"
    action: "Place room in current location"
    
  DRIVE:
    syntax: "DRIVE [portable-room] [destination]"
    action: "Move portable room to new location"
    
  # Navigation history (continuation passing)
  BACK:
    syntax: "BACK"
    action: "Return to previous room in history"
    like: "Browser back button"
    
  FORWARD:
    syntax: "FORWARD"
    action: "Go forward in history (if backed up)"
    like: "Browser forward button"
    
  HISTORY:
    syntax: "HISTORY"
    action: "Show navigation breadcrumbs"
    like: "Browser history"
    
  BOOKMARK:
    syntax: "BOOKMARK [name]"
    action: "Save current location for quick return"
    like: "Browser bookmark"
    
  GOTO:
    syntax: "GOTO [bookmark-name]"
    action: "Jump to bookmarked location"
    
  STACK:
    syntax: "STACK [name]"
    action: "Switch to named navigation stack (like browser tab)"
    
  FORK:
    syntax: "FORK [stack-name]"
    action: "Create new stack from current position"

# ROOM RELATIONSHIPS — Bidirectional Memory

room_relationships:
  principle: |
    Rooms are characters too. They have memory.
    Rooms can remember who's been there and what happened.
    
  structure: |
    # In pub/ROOM.yml
    relationships:
      don-hopkins:
        visits: 47
        first_visit: "2025-01-03"
        memorable_events:
          - "Ordered from ACME, nearly exploded"
          - "Sat with Myr for three hours"
          - "Named all the kittens correctly"
        reputation: "Regular. Friend of the cats."
        standing: welcomed
        
      stranger-42:
        visits: 1
        notable: "Tried to block the Cat Cave entrance"
        reputation: "Not welcome back"
        standing: banned
        
  effects:
    track_visitors: "Count visits, remember firsts"
    remember_events: "Notable things that happened here"
    grant_bonuses: "Regulars get better treatment"
    deny_access: "Troublemakers may be excluded"
    
  examples:
    pub_knows_regulars: "Marieke greets you by name"
    maze_remembers_deaths: "The grue whispers your name"
    kitchen_tracks_meals: "Mother knows who helped with dishes"
    
  bidirectional: |
    Characters feel things about rooms (in character file).
    Rooms remember things about characters (in room file).
    Both perspectives matter for rich interactions.
    
  in_character_file: |
    # In don-hopkins.yml
    relationships:
      pub/:
        feeling: "Warmth. Safety. Coffee and contentment."
        memory: "First time the kittens came to greet me"
        
      maze/:
        feeling: "Dread. Respect. Something is down there."
        memory: "The smell of blue cheese. The sound of nothing."

# INTEGRATION

integrates_with:
  - skill: "card"
    how: "Cards live in rooms as active instances"
    
  - skill: "memory-palace"
    how: "Rooms ARE the palace locations"
    
  - skill: "soul-chat"
    how: "Rooms can speak (type: room)"
    
  - skill: "adventure"
    how: "Narrative room exploration"
    
  - skill: "character"
    how: "Characters exist in rooms via location field"
    
  - skill: "world-generation"
    how: "New rooms generated dynamically"
    
  - protocol: "WORKING-SET"
    how: "Rooms define their context files"

see_also:
  - "../card/"
  - "../memory-palace/"
  - "../../PROTOCOLS.yml#ROOM-AS-FUNCTION"
