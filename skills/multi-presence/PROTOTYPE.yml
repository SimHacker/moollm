# Multi-Presence Skill Prototype
# Same card active in multiple rooms simultaneously

skill: multi-presence
description: "Single card instantiated in multiple rooms with independent state"
origin: "Actor model, parallel processing, distributed systems"

# Core concept
concept: |
  A card is a template. An activation is an instance.
  One card can have many activations, each in a different room,
  each with its own state, all running in parallel.

# Activation structure
activation_schema:
  card: string              # Reference to source card
  instance_id: string       # Unique identifier
  room: string              # Where this activation lives
  tags: list                # Labels for reference
  state: object             # Instance-specific state
  created: timestamp
  status: enum [active, paused, completed, failed]

# Commands
commands:
  PLAY:
    syntax: "PLAY <card> IN <room>"
    effect: "Create new activation of card in room"
    
  INSTANCES:
    syntax: "INSTANCES <card>"
    effect: "List all activations of a card"
    
  BROADCAST:
    syntax: "BROADCAST <message> TO <card>"
    effect: "Send message to all activations of card"
    
  MERGE:
    syntax: "MERGE <instance-1> <instance-2>"
    effect: "Combine two activations' findings"

# Actor model mapping
actor_model:
  actor: "Card activation"
  mailbox: "Room inbox"
  message: "Thrown object"
  spawn: "PLAY card"
  state: "activation.yml"
  supervision: "Room or parent activation"

# Use cases
use_cases:
  parallel_exploration:
    description: "Explore multiple paths simultaneously"
    example: |
      Play researcher in room-A (hypothesis A)
      Play researcher in room-B (hypothesis B)
      Compare results
      
  distributed_work:
    description: "Split large task across instances"
    example: |
      50 documents to analyze
      Play analyst in 5 rooms (10 docs each)
      Aggregate results
      
  consensus:
    description: "Multiple reviewers vote"
    example: |
      Play reviewer 3 times
      Each reviews independently
      Majority vote determines outcome
      
  cross_pollination:
    description: "Instances share insights"
    example: |
      Debugger-A finds pattern
      Debugger-B has context
      Combined insight emerges

# Lifecycle
lifecycle:
  create: "PLAY card IN room"
  run: "Activation processes, updates state"
  block: "Activation waiting for async tool result"
  resume: "Tool result arrived, continue processing"
  complete: "Activation finishes, can delete or transform"
  transform: "Become result card"
  spawn: "Create child activations"
  merge: "Combine with other instance"

# Async tool calls
async_tools:
  description: |
    Activations can block waiting for external tool calls.
    Coherence Engine skips blocked activations until results arrive.
    
  statuses:
    active: "Running, process this epoch"
    blocked: "Waiting for tool result, skip"
    ready: "Tool returned, resume processing"
    paused: "User paused, skip until resumed"
    completed: "Done, can be cleaned up"
    
  blocked_activation:
    status: blocked
    blocked_on:
      tool: string          # Which tool
      query: string         # What was requested
      submitted: timestamp  # When submitted
      expected_duration: string
      
  ready_activation:
    status: ready
    blocked_on: null
    tool_results:
      - tool: string
        completed: timestamp
        result: object

# Communication
communication:
  within_epoch: |
    All activations can communicate instantly
    within a single LLM call (speed of light)
    
  across_epochs: |
    THROW objects between rooms
    Read/write shared files
    Inbox/outbox pattern
