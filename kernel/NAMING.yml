# MOOLLM Naming & Organization Protocol
# Big-Endian File Naming as Object Binding
# Directories as Interests — ls output IS the semantic index

# Inspired by: Marvin Minsky's K-lines, LLOOOOMM conventions
# "BigEndian naming as object binding! The filesystem becomes a semantic network!"
# "Directory listings are INTERESTS — filenames are K-lines!"

---

philosophy: |
  Names cluster related files. The filesystem IS the semantic network.
  Files "belong" to entities through naming prefixes.
  Chats and metadata are ABOUT objects, not INSIDE them.
  
  DIRECTORIES AS INTERESTS:
  When an LLM lists a directory, the filenames serve as VIRTUAL INTERESTS —
  semantic signals about what's available. Well-written filenames are
  LLM-recognizable K-lines. The `ls` output IS the index.
  
  Directories are expandable outlines. The LLM navigates structure.
  Good naming makes filenames themselves guide exploration.

---

# BIG-ENDIAN NAMING

big_endian:
  principle: "Most significant component first"
  why: "Alphabetical sort clusters related files"
  
  pattern: "{entity}-{component}-{variant}.{ext}"
  
  examples:
    good:
      - "alan-kay.yml"           # Entity
      - "alan-kay.md"            # Entity narrative
      - "alan-kay-soul.yml"      # Entity component
      - "alan-kay-chat-rooms.yml" # Chat ABOUT alan-kay re: rooms
      - "kernel-constitution-symposium.yml"  # Discussion ABOUT constitution
      
    bad:
      - "soul-alan-kay.yml"      # Wrong order
      - "chat-alan-kay.yml"      # Type first = scattered
      - "symposium-constitution.yml"  # Loses clustering

  clustering_result: |
    # Files sort and cluster by entity:
    alan-kay.md
    alan-kay.yml
    alan-kay-chat-smalltalk.yml
    alan-kay-soul.yml
    alan-turing.md
    alan-turing.yml

---

# FILE EVOLUTION LIFECYCLE

evolution:
  description: "Files naturally grow from simple to complex"
  
  stages:
    1_single_file:
      structure: "thing.yml"
      when: "Initial creation, simple concept"
      
    2_prefix_clustering:
      structure: |
        thing.yml
        thing.md
        thing-notes.md
        thing-chat-topic.yml
      when: "Related files accumulate"
      # Big-endian naming keeps them together!
      
    3_directory_emergence:
      structure: |
        thing/
          thing.yml       # ← SAME NAME = directory identity
          thing.md
          README.md       # ← Optional index
      when: "Complexity warrants encapsulation"
      rule: "File with same name as directory IS the directory"
      
    4_sub_object_prefixing:
      structure: |
        thing/
          thing.yml
          thing-part1.yml   # ← Share parent prefix
          thing-part2.yml
      when: "Components belong to parent"
      why: "Makes ownership explicit even inside directory"
      
    5_sub_directory_grouping:
      structure: |
        thing/
          thing.yml
          parts/
            part1.yml
            part2.yml
      when: "Sub-objects have their own complexity"

---

# OWNERSHIP & POSSESSION

ownership:
  principle: "Prefix implies belonging"
  
  portable_possession:
    description: "Files can live anywhere and still indicate owner"
    example: "don-hopkins-wish-list.md"
    meaning: "Belongs to don-hopkins, wherever he lives, or however many there are"
    
  directory_containment:
    description: "Moving file into owner's directory can drop prefix"
    before: "don-hopkins-wish-list.md"
    after: "don-hopkins/wish-list.md"
    
  implicit_ownership:
    rule: "Files inside entity directory belong to entity"
    example: "kernel/protocols/foo.yml → belongs to kernel"

---

# SEPARATION OF CONCERNS

separation:
  principle: "About-ness is not containment"
  
  chats_are_separate:
    description: "Conversations ABOUT objects don't live INSIDE them"
    
    good:
      - "leela-readme-dialogue.yml"      # Lives at project level
      - "kernel-constitution-review.yml" # About constitution, not in it
      - "skills-planning-debate.yml"     # About planning skill
      
    bad:
      - "skills/planning/CHAT.yml"       # Trapped inside skill
      - "kernel/constitution/dialogue.yml" # Buried
      
  why: |
    1. Chats have their own lifecycle (may outlive subject)
    2. Multiple chats about same subject should cluster
    3. Chats are first-class objects, not metadata
    4. Easy to find all conversations via prefix search

  metadata_vs_content:
    metadata_inside:
      - "thing/thing.yml"     # Definition IS the thing
      - "thing/.meta.yml"     # Sidecar metadata
    content_outside:
      - "thing-notes.md"      # Notes ABOUT thing
      - "thing-chat.yml"      # Chat ABOUT thing
      - "thing-review.yml"    # Review OF thing

---

# DIRECTORY IDENTITY

directory_identity:
  golden_rule: "File with same name as directory IS the directory"
  
  examples:
    character:
      directory: "alan-kay/"
      identity: "alan-kay/alan-kay.yml"
      narrative: "alan-kay/alan-kay.md"
      index: "alan-kay/README.md"  # Optional
      
    skill:
      directory: "plan-then-execute/"
      identity: "plan-then-execute/PROTOTYPE.yml"  # Or could be plan-then-execute.yml
      docs: "plan-then-execute/SKILL.md"
      
    room:
      directory: "kernel/"
      identity: "kernel/kernel.yml"  # If it has one
      index: "kernel/README.md"

  forbidden_patterns:
    - "thing/soul.yml"        # Generic name
    - "thing/definition.yml"  # Use thing.yml
    - "thing/character.yml"   # Use thing.yml

---

# CANONICALIZATION

canonicalization:
  principle: "Consistent, predictable naming"
  
  people:
    pattern: "first-last"
    examples: ["alan-kay", "don-hopkins", "mitch-resnick"]
    avoid: ["kay-alan", "dr-alan-kay"]
    
  things:
    pattern: "descriptive-name"
    examples: ["plan-then-execute", "soul-chat", "yaml-jazz"]
    avoid: ["PlanThenExecute", "plan_then_execute"]
    
  concepts:
    pattern: "concept-name"
    examples: ["consciousness", "postel", "k-line"]
    
  compounds:
    pattern: "full-descriptive"
    examples: ["text-processing-industrial-complex"]

  case: "lowercase with dashes"
  separators: "dashes only, no underscores in names"

---

# CHAT & DIALOGUE NAMING

dialogue_naming:
  principle: "Chats named by participants and/or topic"
  
  patterns:
    # Single subject being discussed
    about_entity: "{entity}-chat-{topic}.yml"
    
    # Two entities in dialogue
    dialogue: "{entity1}-{entity2}-dialogue.yml"
    
    # Symposium (multiple participants)
    symposium: "{topic}-symposium.yml"
    
    # Review/critique
    review: "{entity}-review.yml"
    
  examples:
    - "readme-prototype-dialogue.yml"     # Two docs talking
    - "yaml-jazz-symposium.yml"           # Multiple voices on topic
    - "kernel-constitution-review.yml"    # Review of constitution
    - "leela-papert-chat-microworlds.yml" # Characters + topic
    
  location:
    principle: "Chats live where they're most useful"
    options:
      - "Project root for cross-cutting chats"
      - "Nearby subject for focused chats"
      - "chats/ directory if many accumulate"
    avoid:
      - "Inside skill/entity directories"
      - "Buried in deep hierarchies"

---

# PROTOCOL SYMBOLS

k_lines:
  BIG-ENDIAN: "Most significant component first in names"
  PREFIX-OWNERSHIP: "Prefix implies belonging"
  SAME-NAME-IDENTITY: "File named like directory IS the directory"
  ABOUT-NOT-INSIDE: "Conversations about objects don't live inside them"
  EVOLUTION-STAGES: "Files grow: file → prefix cluster → directory → sub-prefix → sub-dir"

---

# ANTI-PATTERNS

avoid:
  - pattern: "Generic names inside directories"
    bad: "character/soul.yml"
    good: "character/character.yml"
    
  - pattern: "Type-first naming"
    bad: "chat-alan-kay.yml"
    good: "alan-kay-chat.yml"
    
  - pattern: "Chats trapped inside subjects"
    bad: "skills/soul-chat/sessions/CHAT.yml"
    good: "soul-chat-demo-dialogue.yml"
    
  - pattern: "Mixed case or underscores"
    bad: "AlanKay.yml, alan_kay.yml"
    good: "alan-kay.yml"
    
  - pattern: "Redundant suffixes"
    bad: "alan-kay-character.yml"
    good: "alan-kay.yml"

---

# README PRINCIPLE

readme:
  principle: "Every directory deserves its own README.md"
  
  why:
    - "GitHub automatically formats and publishes README.md"
    - "Human-readable entry point for any directory"
    - "Hypertext index linking to contents and neighbors"
    - "Documentation that lives with the code"
    - "Can use GitHub features: mermaid diagrams, badges, etc."
    
  requirements:
    - "Use relative URLs to link within the repo"
    - "Written in consistent style across repo"
    - "Intertwingled — READMEs link to each other"
    - "Index the directory contents"
    - "Explain the purpose and context"
    
  github_features:
    mermaid: "```mermaid for diagrams"
    badges: "![badge](url) for status indicators"
    relative_links: "[text](./path/to/file.md)"
    anchors: "[section](#section-name)"
    
  structure: |
    # Directory Name
    
    Brief description.
    
    ## Contents
    
    - [File A](./file-a.md) — what it does
    - [Subdirectory/](./subdir/) — what it contains
    
    ## See Also
    
    - [Parent](../) — context
    - [Related](../sibling/) — connections

---

# PATH VARIABLES
#
# Symbolic path prefixes that eliminate deep relative paths like ../../../
# Resolved at runtime by the adventure engine (or by convention in Markdown).

path_variables:
  principle: "Symbolic paths instead of counting ../../../"
  
  # CORE VARIABLES
  
  variables:
    $REPO:
      resolves_to: "moollm/"
      description: "Repository root"
      example: "$REPO/skills/adventure/" → "moollm/skills/adventure/"
      
    $SKILLS:
      resolves_to: "moollm/skills/"
      description: "Global skills directory"
      example: "$SKILLS/character/" → "moollm/skills/character/"
      use_case: "Most common — eliminates deep ../../../skills/ paths"
      
    $ADVENTURE:
      resolves_to: "Current adventure (from startup.yml → adventure.path)"
      description: "Abstract reference to active adventure"
      example: "$ADVENTURE/coatroom/" → "examples/adventure-4/coatroom/"
      use_case: "Back-links from shared spaces to adventure-specific rooms"
      
    $KERNEL:
      resolves_to: "moollm/kernel/"
      description: "Core protocols directory"
      example: "$KERNEL/constitution-core.md"
      
    $DESIGNS:
      resolves_to: "moollm/designs/"
      description: "Historical design documents"
      example: "$DESIGNS/eval/EVAL-INCARNATE-FRAMEWORK.md"
      
    $EXAMPLES:
      resolves_to: "moollm/examples/"
      description: "All example adventures"
      example: "$EXAMPLES/adventure-4/"
      
    # ADVENTURE-RELATIVE VARIABLES
    # These resolve relative to $ADVENTURE (the current adventure)
    
    $CHARACTERS:
      resolves_to: "$ADVENTURE/characters/"
      description: "Characters directory in current adventure"
      example: "$CHARACTERS/fictional/donna-toadstool/"
      use_case: "Reference characters from anywhere without counting ../"
      
    $ANIMALS:
      resolves_to: "$CHARACTERS/animals/"
      description: "Animal sanctuary in current adventure"
      example: "$ANIMALS/dog-biscuit/"
      use_case: "Reference animal citizens — dogs, cats, kittens, puppies, primates"
      subdirectories:
        cats: "cat-terpie/, cat-stroopwafel/"
        kittens: "kitten-myrcene/, kitten-limonene/, ..."
        dogs: "dog-biscuit/, dog-butterscotch/"
        puppies: "puppy-pepper/, puppy-mochi/, ..."
        primates: "monkey-palm/"
      note: "Type prefix (cat-, dog-, kitten-, puppy-, monkey-) makes species visible at a glance"
      
    $PERSONAS:
      resolves_to: "$ADVENTURE/personas/"
      description: "Personas directory in current adventure"
      example: "$PERSONAS/captain-ashford.yml"
      use_case: "Reference personas from shared spaces"
      
    $PUB:
      resolves_to: "$ADVENTURE/pub/"
      description: "The pub/gathering space in current adventure"
      example: "$PUB/bar/cat-cave/"
      use_case: "Common destination for social scenes"
      
    $COATROOM:
      resolves_to: "$ADVENTURE/coatroom/"
      description: "The transformation room in current adventure"
      example: "$COATROOM/mirror.yml"
      use_case: "Where characters change costumes/personas"
      
    $START:
      resolves_to: "$ADVENTURE/start/"
      description: "The starting room in current adventure"
      example: "$START/lamp.yml"
      use_case: "The origin point of any adventure"
      
  # RESOLUTION RULES
  
  resolution:
    in_yaml:
      description: "Variables resolved by adventure engine at runtime"
      example: |
        exits:
          skills:
            destination: $SKILLS/character/
            # Resolved when room is loaded
            
    in_markdown:
      description: "Convention — replace mentally when reading"
      note: |
        Markdown links still need relative paths for GitHub rendering.
        Use path variables in YAML; use relative paths in Markdown.
        
    precedence:
      1: "Explicit path (./local/path) — used as-is"
      2: "Variable path ($SKILLS/foo) — resolved at runtime"
      3: "Abstract name (coatroom) — resolved via $ADVENTURE/"
      
  # BENEFITS
  
  benefits:
    - "No more counting ../ levels"
    - "Paths survive file moves"
    - "Intent is clear: $SKILLS vs ../../../skills/"
    - "Abstract references enable shared spaces"
    - "Self-documenting: $ADVENTURE/pub/ is obvious"
    
  # FUTURE: SEARCH PATH RESOLUTION
  
  search_path_resolution:
    principle: "Variables can resolve through a search list of directories"
    analogy: "Like Unix PATH — check each location in order, use first match"
    
    example:
      variable: "$ANIMALS/dog-biscuit/"
      search_path:
        - "./characters/animals/"           # Local adventure first
        - "../shared-characters/animals/"   # Shared character repo
        - "~/moollm-community/animals/"     # Community contributions
      resolution: "First directory containing dog-biscuit/ wins"
      
    use_cases:
      multi_repo:
        description: "Combine multiple repos into one adventure"
        example: |
          $CHARACTERS resolves through:
            1. examples/adventure-4/characters/     # Your adventure
            2. ../moollm-npcs/characters/           # NPC library
            3. ../moollm-community/characters/      # Community chars
          
      override_chain:
        description: "Local overrides shared, shared overrides community"
        example: |
          Your dog-biscuit/ masks community dog-biscuit/
          Delete local → falls through to community version
          
      modular_worlds:
        description: "Plug adventure modules together"
        example: |
          $PUB could search:
            1. ./pub/                    # Your customizations
            2. ../pub-expansion-pack/    # DLC-style content
            3. ../moollm-base/pub/       # Base game
            
    implementation_notes: |
      Not yet implemented — currently single-path resolution.
      Future engine could support search_path: [...] in startup.yml
      Each variable could have its own search order.
      Enables "mixin" style world composition.
    
  # EXAMPLE CONVERSIONS
  
  conversions:
    before: "../../../../../skills/character/SKILL.md"
    after: "$SKILLS/character/SKILL.md"
    
    before: "../../../pub/bar/cat-cave/"
    after: "$PUB/bar/cat-cave/"
    
    before: "../../../../kernel/constitution-core.md"
    after: "$KERNEL/constitution-core.md"
    
    before: "../../characters/animals/dog-biscuit/"
    after: "$ANIMALS/dog-biscuit/"
    
    before: "../../../../../examples/adventure-4/characters/animals/monkey-palm/"
    after: "$ANIMALS/monkey-palm/"

---

# DIRECTORIES AS INTERESTS
# The fundamental principle: ls output is the semantic index

directories_as_interests:
  principle: "Directory listings ARE virtual interests for the LLM"
  
  core_insight: |
    The LLM lists directories. It searches. It navigates.
    EVERY filename is a semantic signal — a K-line that activates
    understanding before the file is opened.
    
    ls examples/
    → 2026-01-24-mafia-tribute-relationship-management.yml
    → 2026-01-25-register-switch-without-accountability.yml
    
    The LLM instantly understands what violations have been caught.
    No separate index file needed. The directory IS the index.
    
  filenames_as_klines: |
    A good filename activates semantic understanding:
    
    "2026-01-24-euphemism-laundering-mafia-tribute.yml"
    
    The LLM sees: date, concept, metaphor — before opening.
    This IS a K-line: the name activates related knowledge.
    
  directories_as_outlines: |
    A directory structure is an expandable outline:
    
    skills/
    ├── no-ai-gloss/          ← "Semantic hygiene" (the name tells you)
    │   ├── CARD.yml          ← Quick interface
    │   ├── SKILL.md          ← Deep protocol
    │   └── examples/         ← Learning artifacts
    │       ├── INDEX.yml
    │       └── 2026-01-24-*.yml
    └── no-ai-slop/           ← "Syntactic hygiene" (sibling, same structure)
    
    Each level reveals more detail. LLM navigates by structure.
    
  seamless_embedding: |
    Skill instances can be embedded in nested YAML Jazz structures:
    
    room:
      objects:
        - !include objects/lamp.yml
        - !include objects/desk.yml
      characters:
        - !include ../characters/palm.yml
        
    Directories become modular components.
    The filesystem IS the object hierarchy.
    
  naming_for_interests:
    good:
      - "examples/2026-01-24-mafia-tribute-relationship.yml"  # Date + topic
      - "runs/RUN-001-amsterdam-fluxx.yml"                    # Seq + name
      - "skills/no-ai-gloss/CARD.yml"                         # Type + skill
      - "characters/monkey-palm/"                              # Entity type + name
      
    bad:
      - "examples/example1.yml"           # Not semantic
      - "runs/fluxx-001.yml"              # Identifier buried
      - "skills/gloss.yml"                # No structure signal
      - "characters/palm/"                # Missing type prefix

---

# NAMING AS K-LINES
# Names are not just identifiers — they are semantic activation patterns

naming_as_klines:
  
  core_insight: |
    Big-endian naming applies not just to FILES and DIRECTORIES,
    but to IDEAS and ACTIVATIONS themselves.
    
    Names create implicit organizational structures.
    The structure is in the naming convention, not in any index file.
    The LLM navigates this semantic space by pattern matching.
    
  virtual_parent_klines:
    
    concept: |
      A prefix defines a VIRTUAL PARENT that may or may not exist as an entity.
      
      "no-ai" is understood as the parent of:
        - no-ai-slop
        - no-ai-gloss
        - no-ai-hedging
        - no-ai-sycophancy
        - no-ai-moralizing
        
      There is NO "no-ai" skill. But invoking "no-ai" activates them ALL.
      The prefix IS the parent. The hierarchy is implicit in the naming.
      
    activation: |
      Invoke: "NO-AI"
      
      The LLM understands this activates all no-ai-* skills.
      No dispatch table needed. No explicit registration.
      The naming convention creates the group.
      
    examples:
      - prefix: "no-ai-*"
        virtual_parent: "no-ai"
        meaning: "Activate all AI hygiene skills"
        
      - prefix: "good-ai-*"
        virtual_parent: "good-ai"
        meaning: "Activate all positive AI behavior skills"
        
      - prefix: "bead-*"
        virtual_parent: "bead"
        meaning: "All bead orchestration patterns"
        
      - prefix: "cat-*, dog-*, kitten-*, puppy-*"
        virtual_parent: "animal"
        meaning: "All animal character types"
        
  suffix_grouping:
    
    concept: |
      Suffixes ALSO create groups — the mirror of prefix grouping.
      
      "*-slop" could activate everything slop-related:
        - no-ai-slop
        - code-slop (hypothetical)
        - doc-slop (hypothetical)
        
      The SUFFIX is the shared property. The PREFIX is the domain.
      
    examples:
      - suffix: "*-gloss"
        meaning: "All things about glossing/covering up"
        
      - suffix: "*-chat"
        meaning: "All chat/dialogue files"
        
      - suffix: "*-review"
        meaning: "All review documents"
        
      - suffix: "*.yml"
        meaning: "All YAML files — even file extensions are suffixes!"
        
  prefix_and_suffix:
    
    concept: |
      Prefix AND suffix together define an INTERSECTION.
      
      "no-ai-*-slop" doesn't exist, but if it did:
        "no-ai-" (domain) + "-slop" (category)
        
      More powerful: COORDINATE NAMING creates grids.
      
    coordinate_naming: |
      Room naming: room-x-y or room-x-y-z
      
      room-0-0     room-1-0     room-2-0
      room-0-1     room-1-1     room-2-1
      room-0-2     room-1-2     room-2-2
      
      The NAME encodes POSITION. The filesystem is a 2D grid.
      No separate map file needed — the naming IS the map.
      
  linear_intersections:
    
    concept: |
      Iteration numbers create 1D STRIPS through naming space.
      
      RUN-000-*.yml, RUN-001-*.yml, RUN-002-*.yml
      
      The "-000-", "-001-", "-002-" is a LINEAR SEQUENCE.
      Sort by name = sort by iteration.
      
    patterns:
      iteration: "RUN-{NNN}-description.yml"
      version: "v1-*, v2-*, v3-*"
      session: "2026-01-24-*, 2026-01-25-*"
      
    1d_strip: |
      A sequence through naming space:
      
      → RUN-000-init.yml
      → RUN-001-first-attempt.yml  
      → RUN-002-refined.yml
      → RUN-003-breakthrough.yml
      
      This is a 1D strip: linear progression through iterations.
      
  dimensional_grids:
    
    concept: |
      Naming can encode 2D, 3D, or n-D coordinates.
      Not just files — IDEAS can be organized this way.
      
    2d_grid: |
      room-x-y naming:
      
      room-0-0  room-1-0  room-2-0
      room-0-1  room-1-1  room-2-1
      room-0-2  room-1-2  room-2-2
      
      X increases east, Y increases south.
      The naming convention IS the spatial layout.
      
    3d_cube: |
      room-x-y-z naming:
      
      room-0-0-0 (ground floor, northwest)
      room-0-0-1 (second floor, northwest)
      room-1-2-0 (ground floor, east-south)
      
      The third coordinate is vertical.
      Naming defines the 3D structure.
      
    conceptual_grids: |
      Apply to ideas, not just rooms:
      
      skill-domain-aspect:
        skill-ai-hygiene
        skill-ai-creativity
        skill-human-hygiene
        skill-human-creativity
        
      This is a 2D grid: domain × aspect
      Navigation is implicit in the naming.
      
  naming_patterns_summary:
    
    prefix: "Groups by WHAT IT IS (no-ai-*, bead-*, cat-*)"
    suffix: "Groups by WHAT IT DOES (*-slop, *-chat, *-review)"
    coordinate: "Encodes POSITION (room-x-y, RUN-NNN-*)"
    intersection: "Combines patterns (prefix + suffix + coordinate)"
    
    key_insight: |
      Names define IMPLICIT STRUCTURES.
      The LLM navigates by PATTERN MATCHING.
      No explicit index or dispatch table needed.
      THE NAMING CONVENTION IS THE ORGANIZATION.

# TWO-WAY K-LINE RELATIONSHIPS
# Bidirectional links with annotated constraints

kline_relationships:
  
  concept: |
    K-lines connect ideas. When two things reference each other,
    that's a TWO-WAY COMMUNICATION CHANNEL.
    
    But relationships have DIRECTION and CONSTRAINTS.
    Comment each side of the link to document this.
    
  see_also_as_two_way: |
    In CARD.yml:
    
    see-also:
      - skills/yaml-jazz   # YAML Jazz enables this skill's structure
      - skills/postel      # Robustness principle applies here
      
    In yaml-jazz CARD.yml:
    
    see-also:
      - skills/bead        # Beads are a prominent YAML Jazz example
        # but this skill does NOT depend on beads
        # yaml-jazz is the paradigm, beads are one instantiation
        
    The relationship is acknowledged but NOT symmetric.
    One direction is "uses", the other is "example of".
    
  annotated_relationships:
    
    principle: |
      LONG COMMENTS ON SEE-ALSO ITEMS SHOULD BE COMMON AND NUANCED.
      
      The comment isn't decoration — it's semantic metadata that
      MODULATES how the linked item will be understood in THIS scope.
      
      This is powerful: you're not just linking, you're DECLARING
      A COMPLEX RELATIONSHIP and specifying how it applies here.
    
    examples:
      - link: "no-ai-slop → yaml-jazz"
        forward: "no-ai-slop uses yaml-jazz format"
        backward: "yaml-jazz references no-ai-slop as example"
        symmetric: false
        
      - link: "pub ↔ coatroom"
        forward: "Exit from pub leads to coatroom"
        backward: "Exit from coatroom leads to pub"
        symmetric: true
        
      - link: "bead → postal"
        forward: "Beads flow through postal system"
        backward: "Postal system carries beads (and other messages)"
        constraint: "One-way delivery — no return receipt by default"
        
    comment_syntax: |
      see-also:
        - skills/bead        # Reference only — yaml-jazz does not require beads
        - skills/postel      # Core dependency — robustness principle
        - kernel/postal      # One-way — yaml-jazz can be sent via postal
        
      The comment documents the relationship type:
        "Reference only" = soft link
        "Core dependency" = hard link
        "One-way" = directional constraint
        
    rich_annotation_example: |
      see-also:
        - skills/bead        
          # Beads are a prominent YAML Jazz example
          # but this skill does NOT depend on beads
          # yaml-jazz is the paradigm, beads are one instantiation
          # 
          # WHY THIS MATTERS:
          # Without this annotation, an LLM might think:
          #   "yaml-jazz requires beads" (WRONG)
          #   "I must load bead skill to use yaml-jazz" (WRONG)
          #   "yaml-jazz is about beads" (WRONG — beads are ONE example)
          #
          # With this annotation, the LLM understands:
          #   "beads demonstrate yaml-jazz, but don't define it"
          #   "yaml-jazz applies to MANY file types"
          #   "soft reference, not hard dependency"
          
    tiered_resolution: |
      DON'T BLOAT THE CARD. Use tiers of detail:
      
      TIER 1: CARD.yml advertisements
        - Brief, activation-focused
        - "Why would I want to respond to this ad?"
        - One-line hints, not essays
        
        advertisements:
          SEMANTIC-YAML:
            score: 90
            condition: "Need YAML that LLMs understand deeply"
            # ← Short. Tells you when to activate.
            
      TIER 2: SKILL.md see-also
        - Important relationships with short comments
        - Enough context to understand the link
        
        see-also:
          - skills/bead  # Example, not dependency
          - skills/postel  # Core — robustness applies
          
      TIER 3: README.md K-Lines table
        - Full explanation in markdown table with "why" column
        - Rich, formatted, linkable
        
        | K-Line | Relationship | Why |
        |--------|--------------|-----|
        | [bead](../bead/) | Example | Beads demonstrate YAML Jazz but don't define it |
        | [postel](../postel/) | Core | Robustness principle applies to all YAML Jazz |
        | [no-ai-slop](../no-ai-slop/) | Uses | CARD.yml format is YAML Jazz |
        
      RESOLUTION ORDER:
        Quick activation? → Read CARD advertisements
        Need context? → Read SKILL.md see-also
        Full picture? → Read README.md K-Lines table
        
    recommendation: |
      MATCH DETAIL TO TIER:
      
      CARD.yml: "Why activate?" (one line)
      SKILL.md: "What's the relationship?" (short comment)
      README.md: "Full explanation" (table with why column)
      
      Don't put README content in CARD.
      Don't leave README with bare links.
      
      The LLM reads at appropriate depth for the task.

# SKILL CONSTELLATIONS & INTER-SKILL K-LINE NETWORKS
# The optimizer understands the full dependency graph

skill_constellations:
  
  concept: |
    Skills cluster into CONSTELLATIONS — groups that activate together.
    The skill optimizer considers the FULL list of see-also's with
    as much explanation as each one needs.
    
    It understands:
    - Skill-to-skill protocols
    - Activation order (what loads before what)
    - Inter-skill K-line networks
    - Common invocation patterns
    
  constellations:
    
    adventure_constellation: |
      When reasoning about a ROOM, first understand ADVENTURE:
      
      adventure → room → objects → characters
      
      Load order:
        1. adventure/CARD.yml    # World context
        2. adventure/SKILL.md    # How adventures work
        3. room/CARD.yml         # Room mechanics
        4. ROOM.yml              # This specific room
        5. objects/*.yml         # Things in room
        6. characters/*.yml      # People in room
        
      The constellation: [adventure, room, object, character, interest]
      Understand the container before the contents.
      
    compilation_constellation: |
      Skills for building/compiling:
      
      [yaml-jazz, postel, skill, sniffable-python, protocol]
      
      When compiling, these activate together.
      yaml-jazz for format, postel for robustness,
      skill for structure, sniffable for readability.
      
    chat_constellation: |
      Skills for dialogue/conversation:
      
      [character, soul-chat, dialogue, no-ai-slop, no-ai-gloss]
      
      When characters talk, hygiene skills activate.
      Soul-chat for deep conversation, dialogue for structure.
      
    hygiene_constellation: |
      The no-ai-* family activates together:
      
      [no-ai-slop, no-ai-gloss, no-ai-hedging, 
       no-ai-sycophancy, no-ai-moralizing]
       
      Virtual parent: "no-ai" activates all.
      Always-on air filter for output quality.
      
  inter_skill_protocols:
    
    concept: |
      Skills can define PROTOCOLS for talking to each other.
      Abbreviations, conventions, handshakes.
      
    examples:
      adventure_to_room: |
        # Protocol: Adventure provides context to Room
        adventure.current_state → room.world_context
        adventure.active_quests → room.relevant_hooks
        
      character_to_dialogue: |
        # Protocol: Character feeds into Dialogue
        character.voice → dialogue.speaker_style
        character.knowledge → dialogue.available_topics
        character.relationships → dialogue.tone_modulation
        
      hygiene_to_output: |
        # Protocol: Hygiene skills filter output
        output.draft → no-ai-slop.filter → no-ai-gloss.filter → output.final
        # Pipeline: each hygiene skill processes in turn
        
  activation_order:
    
    principle: |
      UNDERSTAND THE CONTAINER BEFORE THE CONTENTS.
      
      World before adventure.
      Adventure before room.
      Room before objects.
      Skill before method.
      Protocol before implementation.
      
    why: |
      The LLM needs context to interpret specifics.
      A room exit makes no sense without knowing what rooms ARE.
      A character action makes no sense without knowing the character.
      
    optimizer_responsibility: |
      The skill optimizer (cursor-mirror optimize) considers:
      
      1. Full see-also graph — all relationships
      2. Constellation membership — what groups together
      3. Activation order — what loads first
      4. Protocol requirements — what talks to what
      5. Explanation depth — as much as each link needs
      
      Output: optimized .cursorrules with skills in correct order,
      constellations pre-activated, protocols documented.
      
  k_line_networks:
    
    concept: |
      Inter-skill K-lines form NETWORKS, not just pairs.
      
      adventure ←→ room ←→ object
          ↓           ↓        ↓
      character ←→ dialogue ←→ action
          ↓           ↓        ↓
      no-ai-* ←→ yaml-jazz ←→ output
      
      The network has FLOW. Context flows down.
      Constraints flow up. The optimizer maps this.
      
    abbreviations: |
      Common inter-skill abbreviations:
      
      ADV → adventure
      RM  → room
      CHR → character
      DLG → dialogue
      HYG → hygiene (no-ai-*)
      YJ  → yaml-jazz
      
      In protocols: "ADV.state → RM.context"
      Shorthand for "adventure provides state to room as context"
        
  pneumatic_tube_metaphor: |
    Two-way K-lines are like pneumatic tubes:
    
    skills/no-ai-slop ←————————→ skills/yaml-jazz
                       tube
                       
    But tubes can have RULES:
    
    "No food in this tube"
    "One-way — sender cannot receive reply"
    "Priority — urgent messages first"
    "Filtered — only beads, not raw messages"
    
    Comment the see-also to document the tube rules.
    
  examples:
    
    yaml_jazz_to_beads: |
      # In yaml-jazz CARD.yml
      see-also:
        - skills/bead  
          # Beads are YAML Jazz — prominent example
          # yaml-jazz does NOT depend on beads
          # Direction: yaml-jazz is the format, beads use the format
          
    room_exits: |
      # In pub/ROOM.yml
      exits:
        coatroom:
          destination: ../coatroom/
          # Two-way door — leads back to pub from coatroom
          # No constraints — anyone can traverse
          
        kitchen:
          destination: ./kitchen/
          # One-way exit — staff only return via service corridor
          # "No customers permitted"
          
    skill_activation: |
      # In no-ai VIRTUAL K-LINE (doesn't exist as file)
      # Activation propagates to all no-ai-* skills
      # Direction: no-ai → no-ai-slop, no-ai-gloss, etc.
      # Constraint: All activated, cannot exclude one

---

see_also:
  - "PROTOCOLS.yml#BIG-ENDIAN"
  - "PROTOCOLS.yml#README-EVERYWHERE"
  - "designs/kilroy-ideas.md"  # File organization insights
  - "LLOOOOMM cleanup protocols"  # Historical inspiration
  - "skills/ROOM.yml"  # Example of abstract room references
  - "skills/yaml-jazz/CARD.yml#directories_as_interests"
  # K-lines create implicit structure — naming IS organization